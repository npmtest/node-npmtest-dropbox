{"/home/travis/build/npmtest/node-npmtest-dropbox/test.js":"/* istanbul instrument in package npmtest_dropbox */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-dropbox/lib.npmtest_dropbox.js":"/* istanbul instrument in package npmtest_dropbox */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_dropbox = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_dropbox = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-dropbox/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-dropbox && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_dropbox */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_dropbox\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_dropbox.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_dropbox.rollup.js'] =\n            local.assetsDict['/assets.npmtest_dropbox.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_dropbox.__dirname + '/lib.npmtest_dropbox.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-dropbox/node_modules/dropbox/src/index.js":"var Dropbox = require('./dropbox');\n\nmodule.exports = Dropbox;\n","/home/travis/build/npmtest/node-npmtest-dropbox/node_modules/dropbox/src/dropbox.js":"var DropboxBase = require('./dropbox-base');\nvar routes = require('./routes');\nvar Dropbox;\n\n/**\n * @class Dropbox\n * @extends DropboxBase\n * @classdesc The Dropbox SDK class that provides methods to read, write and\n * create files or folders in a user's Dropbox.\n * @arg {Object} options\n * @arg {String} [options.accessToken] - An access token for making authenticated\n * requests.\n * @arg {String} [options.clientId] - The client id for your app. Used to create\n * authentication URL.\n * @arg {String} [options.selectUser] - Select user is only used by DropboxTeam.\n * It specifies which user the team access token should be acting as.\n */\nDropbox = function (options) {\n  DropboxBase.call(this, options);\n};\n\nDropbox.prototype = Object.create(DropboxBase.prototype);\n\nDropbox.prototype.constructor = Dropbox;\n\n// Add the user endpoint methods to the prototype\nDropbox.prototype = Object.assign(Dropbox.prototype, routes);\n\nDropbox.prototype.filesGetSharedLinkFile = function (arg) {\n  return this.request('sharing/get_shared_link_file', arg, 'api', 'download');\n};\n\nmodule.exports = Dropbox;\n","/home/travis/build/npmtest/node-npmtest-dropbox/node_modules/dropbox/src/dropbox-base.js":"var REQUEST_CONSTANTS = require('./request-constants');\nvar DropboxBase;\n\n// Polyfill Object.assign() for older browsers\nrequire('./object-assign-polyfill');\n\n/**\n * @private\n * @class DropboxBase\n * @classdesc The main Dropbox SDK class. This contains the methods that are\n * shared between Dropbox and DropboxTeam classes. It is marked as private so\n * that it doesn't show up in the docs because it is never used directly.\n * @arg {Object} options\n * @arg {String} [options.accessToken] - An access token for making authenticated\n * requests.\n * @arg {String} [options.clientId] - The client id fo ryour app. Used to create\n * authentication URL.\n * @arg {Number} [options.selectUser] - User is the team access token would like\n * to act as.\n */\nDropboxBase = function (options) {\n  options = options || {};\n  this.accessToken = options.accessToken;\n  this.clientId = options.clientId;\n  this.selectUser = options.selectUser;\n};\n\n/**\n * Set the access token used to authenticate requests to the API.\n * @arg {String} accessToken - An access token\n * @returns {undefined}\n */\nDropboxBase.prototype.setAccessToken = function (accessToken) {\n  this.accessToken = accessToken;\n};\n\n/**\n * Get the access token\n * @returns {String} Access token\n */\nDropboxBase.prototype.getAccessToken = function () {\n  return this.accessToken;\n};\n\n/**\n * Set the client id, which is used to help gain an access token.\n * @arg {String} clientId - Your apps client id\n * @returns {undefined}\n */\nDropboxBase.prototype.setClientId = function (clientId) {\n  this.clientId = clientId;\n};\n\n/**\n * Get the client id\n * @returns {String} Client id\n */\nDropboxBase.prototype.getClientId = function () {\n  return this.clientId;\n};\n\n/**\n * Get a URL that can be used to authenticate users for the Dropbox API.\n * @arg {String} redirectUri - A URL to redirect the user to after\n * authenticating. This must be added to your app through the admin interface.\n * @arg {String} [state] - State that will be returned in the redirect URL to help\n * prevent cross site scripting attacks.\n * @returns {String} Url to send user to for Dropbox API authentication\n */\nDropboxBase.prototype.getAuthenticationUrl = function (redirectUri, state) {\n  var AUTH_BASE_URL = 'https://www.dropbox.com/oauth2/authorize';\n  var clientId = this.getClientId();\n  var authUrl;\n  if (!clientId) {\n    throw new Error('A client id is required. You can set the client id using .setClientId().');\n  }\n  if (!redirectUri) {\n    throw new Error('A redirect uri is required.');\n  }\n\n  authUrl = AUTH_BASE_URL + '?response_type=token&client_id=' + clientId;\n  if (redirectUri) {\n    authUrl = authUrl + '&redirect_uri=' + redirectUri;\n  }\n  if (state) {\n    authUrl = authUrl + '&state=' + state;\n  }\n  return authUrl;\n};\n\nDropboxBase.prototype.request = function (path, args, auth, host, style) {\n  var request = null;\n  switch (style) {\n    case REQUEST_CONSTANTS.RPC:\n      request = this.getRpcRequest();\n      break;\n    case REQUEST_CONSTANTS.DOWNLOAD:\n      request = this.getDownloadRequest();\n      break;\n    case REQUEST_CONSTANTS.UPLOAD:\n      request = this.getUploadRequest();\n      break;\n    default:\n      throw new Error('Invalid request style: ' + style);\n  }\n\n  return request(path, args, auth, host, this.getAccessToken(), this.selectUser);\n};\n\nDropboxBase.prototype.setRpcRequest = function (newRpcRequest) {\n  DropboxBase.prototype.rpcRequest = newRpcRequest;\n};\n\nDropboxBase.prototype.getRpcRequest = function () {\n  if (DropboxBase.prototype.rpcRequest === undefined) {\n    DropboxBase.prototype.rpcRequest = require('./rpc-request');\n  }\n\n  return DropboxBase.prototype.rpcRequest;\n};\n\nDropboxBase.prototype.setDownloadRequest = function (newDownloadRequest) {\n  DropboxBase.prototype.downloadRequest = newDownloadRequest;\n};\n\nDropboxBase.prototype.getDownloadRequest = function () {\n  if (DropboxBase.prototype.downloadRequest === undefined) {\n    DropboxBase.prototype.downloadRequest = require('./download-request');\n  }\n\n  return DropboxBase.prototype.downloadRequest;\n};\n\nDropboxBase.prototype.setUploadRequest = function (newUploadRequest) {\n  DropboxBase.prototype.uploadRequest = newUploadRequest;\n};\n\nDropboxBase.prototype.getUploadRequest = function () {\n  if (DropboxBase.prototype.uploadRequest === undefined) {\n    DropboxBase.prototype.uploadRequest = require('./upload-request');\n  }\n\n  return DropboxBase.prototype.uploadRequest;\n};\n\nmodule.exports = DropboxBase;\n","/home/travis/build/npmtest/node-npmtest-dropbox/node_modules/dropbox/src/request-constants.js":"var REQUEST_CONSTANTS = {\n  RPC: 'rpc',\n  DOWNLOAD: 'download',\n  UPLOAD: 'upload'\n};\n\nmodule.exports = REQUEST_CONSTANTS;\n","/home/travis/build/npmtest/node-npmtest-dropbox/node_modules/dropbox/src/object-assign-polyfill.js":"// Polyfill object.assign for legacy browsers\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\nif (typeof Object.assign !== 'function') {\n  (function () {\n    Object.assign = function (target) {\n      'use strict';\n      var output;\n      var index;\n      var source;\n      var nextKey;\n      if (target === undefined || target === null) {\n        throw new TypeError('Cannot convert undefined or null to object');\n      }\n\n      output = Object(target);\n      for (index = 1; index < arguments.length; index++) {\n        source = arguments[index];\n        if (source !== undefined && source !== null) {\n          for (nextKey in source) {\n            if (source.hasOwnProperty(nextKey)) {\n              output[nextKey] = source[nextKey];\n            }\n          }\n        }\n      }\n      return output;\n    };\n  }());\n}\n","/home/travis/build/npmtest/node-npmtest-dropbox/node_modules/dropbox/src/routes.js":"// Auto-generated by Stone, do not modify.\nvar routes = {};\n\n/**\n * Creates an OAuth 2.0 access token from the supplied OAuth 1.0 access token.\n * @function Dropbox#authTokenFromOauth1\n * @arg {AuthTokenFromOAuth1Arg} arg - The request parameters.\n * @returns {Promise.<AuthTokenFromOAuth1Result, Error.<AuthTokenFromOAuth1Error>>}\n */\nroutes.authTokenFromOauth1 = function (arg) {\n  return this.request('auth/token/from_oauth1', arg, 'app', 'api', 'rpc');\n};\n\n/**\n * Disables the access token used to authenticate the call.\n * @function Dropbox#authTokenRevoke\n * @arg {void} arg - The request parameters.\n * @returns {Promise.<void, Error.<void>>}\n */\nroutes.authTokenRevoke = function (arg) {\n  return this.request('auth/token/revoke', arg, 'user', 'api', 'rpc');\n};\n\n/**\n * Returns the metadata for a file or folder. This is an alpha endpoint\n * compatible with the properties API. Note: Metadata for the root folder is\n * unsupported.\n * @function Dropbox#filesAlphaGetMetadata\n * @arg {FilesAlphaGetMetadataArg} arg - The request parameters.\n * @returns {Promise.<(FilesFileMetadata|FilesFolderMetadata|FilesDeletedMetadata), Error.<FilesAlphaGetMetadataError>>}\n */\nroutes.filesAlphaGetMetadata = function (arg) {\n  return this.request('files/alpha/get_metadata', arg, 'user', 'api', 'rpc');\n};\n\n/**\n * Create a new file with the contents provided in the request. Note that this\n * endpoint is part of the properties API alpha and is slightly different from\n * upload. Do not use this to upload a file larger than 150 MB. Instead, create\n * an upload session with upload_session/start.\n * @function Dropbox#filesAlphaUpload\n * @arg {FilesCommitInfoWithProperties} arg - The request parameters.\n * @returns {Promise.<FilesFileMetadata, Error.<FilesUploadErrorWithProperties>>}\n */\nroutes.filesAlphaUpload = function (arg) {\n  return this.request('files/alpha/upload', arg, 'user', 'content', 'upload');\n};\n\n/**\n * Copy a file or folder to a different location in the user's Dropbox. If the\n * source path is a folder all its contents will be copied.\n * @function Dropbox#filesCopy\n * @arg {FilesRelocationArg} arg - The request parameters.\n * @returns {Promise.<(FilesFileMetadata|FilesFolderMetadata|FilesDeletedMetadata), Error.<FilesRelocationError>>}\n */\nroutes.filesCopy = function (arg) {\n  return this.request('files/copy', arg, 'user', 'api', 'rpc');\n};\n\n/**\n * Copy multiple files or folders to different locations at once in the user's\n * Dropbox. If RelocationBatchArg.allow_shared_folder is false, this route is\n * atomic. If on entry failes, the whole transaction will abort. If\n * RelocationBatchArg.allow_shared_folder is true, not atomicity is guaranteed,\n * but you will be able to copy the contents of shared folders to new locations.\n * This route will return job ID immediately and do the async copy job in\n * background. Please use copy_batch/check to check the job status.\n * @function Dropbox#filesCopyBatch\n * @arg {FilesRelocationBatchArg} arg - The request parameters.\n * @returns {Promise.<FilesRelocationBatchLaunch, Error.<void>>}\n */\nroutes.filesCopyBatch = function (arg) {\n  return this.request('files/copy_batch', arg, 'user', 'api', 'rpc');\n};\n\n/**\n * Returns the status of an asynchronous job for copy_batch. If success, it\n * returns list of results for each entry.\n * @function Dropbox#filesCopyBatchCheck\n * @arg {AsyncPollArg} arg - The request parameters.\n * @returns {Promise.<FilesRelocationBatchJobStatus, Error.<AsyncPollError>>}\n */\nroutes.filesCopyBatchCheck = function (arg) {\n  return this.request('files/copy_batch/check', arg, 'user', 'api', 'rpc');\n};\n\n/**\n * Get a copy reference to a file or folder. This reference string can be used\n * to save that file or folder to another user's Dropbox by passing it to\n * copy_reference/save.\n * @function Dropbox#filesCopyReferenceGet\n * @arg {FilesGetCopyReferenceArg} arg - The request parameters.\n * @returns {Promise.<FilesGetCopyReferenceResult, Error.<FilesGetCopyReferenceError>>}\n */\nroutes.filesCopyReferenceGet = function (arg) {\n  return this.request('files/copy_reference/get', arg, 'user', 'api', 'rpc');\n};\n\n/**\n * Save a copy reference returned by copy_reference/get to the user's Dropbox.\n * @function Dropbox#filesCopyReferenceSave\n * @arg {FilesSaveCopyReferenceArg} arg - The request parameters.\n * @returns {Promise.<FilesSaveCopyReferenceResult, Error.<FilesSaveCopyReferenceError>>}\n */\nroutes.filesCopyReferenceSave = function (arg) {\n  return this.request('files/copy_reference/save', arg, 'user', 'api', 'rpc');\n};\n\n/**\n * Create a folder at a given path.\n * @function Dropbox#filesCreateFolder\n * @arg {FilesCreateFolderArg} arg - The request parameters.\n * @returns {Promise.<FilesFolderMetadata, Error.<FilesCreateFolderError>>}\n */\nroutes.filesCreateFolder = function (arg) {\n  return this.request('files/create_folder', arg, 'user', 'api', 'rpc');\n};\n\n/**\n * Delete the file or folder at a given path. If the path is a folder, all its\n * contents will be deleted too. A successful response indicates that the file\n * or folder was deleted. The returned metadata will be the corresponding\n * FileMetadata or FolderMetadata for the item at time of deletion, and not a\n * DeletedMetadata object.\n * @function Dropbox#filesDelete\n * @arg {FilesDeleteArg} arg - The request parameters.\n * @returns {Promise.<(FilesFileMetadata|FilesFolderMetadata|FilesDeletedMetadata), Error.<FilesDeleteError>>}\n */\nroutes.filesDelete = function (arg) {\n  return this.request('files/delete', arg, 'user', 'api', 'rpc');\n};\n\n/**\n * Delete multiple files/folders at once. This route is asynchronous, which\n * returns a job ID immediately and runs the delete batch asynchronously. Use\n * delete_batch/check to check the job status.\n * @function Dropbox#filesDeleteBatch\n * @arg {FilesDeleteBatchArg} arg - The request parameters.\n * @returns {Promise.<FilesDeleteBatchLaunch, Error.<void>>}\n */\nroutes.filesDeleteBatch = function (arg) {\n  return this.request('files/delete_batch', arg, 'user', 'api', 'rpc');\n};\n\n/**\n * Returns the status of an asynchronous job for delete_batch. If success, it\n * returns list of result for each entry.\n * @function Dropbox#filesDeleteBatchCheck\n * @arg {AsyncPollArg} arg - The request parameters.\n * @returns {Promise.<FilesDeleteBatchJobStatus, Error.<AsyncPollError>>}\n */\nroutes.filesDeleteBatchCheck = function (arg) {\n  return this.request('files/delete_batch/check', arg, 'user', 'api', 'rpc');\n};\n\n/**\n * Download a file from a user's Dropbox.\n * @function Dropbox#filesDownload\n * @arg {FilesDownloadArg} arg - The request parameters.\n * @returns {Promise.<FilesFileMetadata, Error.<FilesDownloadError>>}\n */\nroutes.filesDownload = function (arg) {\n  return this.request('files/download', arg, 'user', 'content', 'download');\n};\n\n/**\n * Returns the metadata for a file or folder. Note: Metadata for the root folder\n * is unsupported.\n * @function Dropbox#filesGetMetadata\n * @arg {FilesGetMetadataArg} arg - The request parameters.\n * @returns {Promise.<(FilesFileMetadata|FilesFolderMetadata|FilesDeletedMetadata), Error.<FilesGetMetadataError>>}\n */\nroutes.filesGetMetadata = function (arg) {\n  return this.request('files/get_metadata', arg, 'user', 'api', 'rpc');\n};\n\n/**\n * Get a preview for a file. Currently previews are only generated for the files\n * with  the following extensions: .doc, .docx, .docm, .ppt, .pps, .ppsx, .ppsm,\n * .pptx, .pptm,  .xls, .xlsx, .xlsm, .rtf.\n * @function Dropbox#filesGetPreview\n * @arg {FilesPreviewArg} arg - The request parameters.\n * @returns {Promise.<FilesFileMetadata, Error.<FilesPreviewError>>}\n */\nroutes.filesGetPreview = function (arg) {\n  return this.request('files/get_preview', arg, 'user', 'content', 'download');\n};\n\n/**\n * Get a temporary link to stream content of a file. This link will expire in\n * four hours and afterwards you will get 410 Gone. Content-Type of the link is\n * determined automatically by the file's mime type.\n * @function Dropbox#filesGetTemporaryLink\n * @arg {FilesGetTemporaryLinkArg} arg - The request parameters.\n * @returns {Promise.<FilesGetTemporaryLinkResult, Error.<FilesGetTemporaryLinkError>>}\n */\nroutes.filesGetTemporaryLink = function (arg) {\n  return this.request('files/get_temporary_link', arg, 'user', 'api', 'rpc');\n};\n\n/**\n * Get a thumbnail for an image. This method currently supports files with the\n * following file extensions: jpg, jpeg, png, tiff, tif, gif and bmp. Photos\n * that are larger than 20MB in size won't be converted to a thumbnail.\n * @function Dropbox#filesGetThumbnail\n * @arg {FilesThumbnailArg} arg - The request parameters.\n * @returns {Promise.<FilesFileMetadata, Error.<FilesThumbnailError>>}\n */\nroutes.filesGetThumbnail = function (arg) {\n  return this.request('files/get_thumbnail', arg, 'user', 'content', 'download');\n};\n\n/**\n * Starts returning the contents of a folder. If the result's\n * ListFolderResult.has_more field is true, call list_folder/continue with the\n * returned ListFolderResult.cursor to retrieve more entries. If you're using\n * ListFolderArg.recursive set to true to keep a local cache of the contents of\n * a Dropbox account, iterate through each entry in order and process them as\n * follows to keep your local state in sync: For each FileMetadata, store the\n * new entry at the given path in your local state. If the required parent\n * folders don't exist yet, create them. If there's already something else at\n * the given path, replace it and remove all its children. For each\n * FolderMetadata, store the new entry at the given path in your local state. If\n * the required parent folders don't exist yet, create them. If there's already\n * something else at the given path, replace it but leave the children as they\n * are. Check the new entry's FolderSharingInfo.read_only and set all its\n * children's read-only statuses to match. For each DeletedMetadata, if your\n * local state has something at the given path, remove it and all its children.\n * If there's nothing at the given path, ignore this entry.\n * @function Dropbox#filesListFolder\n * @arg {FilesListFolderArg} arg - The request parameters.\n * @returns {Promise.<FilesListFolderResult, Error.<FilesListFolderError>>}\n */\nroutes.filesListFolder = function (arg) {\n  return this.request('files/list_folder', arg, 'user', 'api', 'rpc');\n};\n\n/**\n * Once a cursor has been retrieved from list_folder, use this to paginate\n * through all files and retrieve updates to the folder, following the same\n * rules as documented for list_folder.\n * @function Dropbox#filesListFolderContinue\n * @arg {FilesListFolderContinueArg} arg - The request parameters.\n * @returns {Promise.<FilesListFolderResult, Error.<FilesListFolderContinueError>>}\n */\nroutes.filesListFolderContinue = function (arg) {\n  return this.request('files/list_folder/continue', arg, 'user', 'api', 'rpc');\n};\n\n/**\n * A way to quickly get a cursor for the folder's state. Unlike list_folder,\n * list_folder/get_latest_cursor doesn't return any entries. This endpoint is\n * for app which only needs to know about new files and modifications and\n * doesn't need to know about files that already exist in Dropbox.\n * @function Dropbox#filesListFolderGetLatestCursor\n * @arg {FilesListFolderArg} arg - The request parameters.\n * @returns {Promise.<FilesListFolderGetLatestCursorResult, Error.<FilesListFolderError>>}\n */\nroutes.filesListFolderGetLatestCursor = function (arg) {\n  return this.request('files/list_folder/get_latest_cursor', arg, 'user', 'api', 'rpc');\n};\n\n/**\n * A longpoll endpoint to wait for changes on an account. In conjunction with\n * list_folder/continue, this call gives you a low-latency way to monitor an\n * account for file changes. The connection will block until there are changes\n * available or a timeout occurs. This endpoint is useful mostly for client-side\n * apps. If you're looking for server-side notifications, check out our webhooks\n * documentation https://www.dropbox.com/developers/reference/webhooks.\n * @function Dropbox#filesListFolderLongpoll\n * @arg {FilesListFolderLongpollArg} arg - The request parameters.\n * @returns {Promise.<FilesListFolderLongpollResult, Error.<FilesListFolderLongpollError>>}\n */\nroutes.filesListFolderLongpoll = function (arg) {\n  return this.request('files/list_folder/longpoll', arg, 'noauth', 'notify', 'rpc');\n};\n\n/**\n * Return revisions of a file.\n * @function Dropbox#filesListRevisions\n * @arg {FilesListRevisionsArg} arg - The request parameters.\n * @returns {Promise.<FilesListRevisionsResult, Error.<FilesListRevisionsError>>}\n */\nroutes.filesListRevisions = function (arg) {\n  return this.request('files/list_revisions', arg, 'user', 'api', 'rpc');\n};\n\n/**\n * Move a file or folder to a different location in the user's Dropbox. If the\n * source path is a folder all its contents will be moved.\n * @function Dropbox#filesMove\n * @arg {FilesRelocationArg} arg - The request parameters.\n * @returns {Promise.<(FilesFileMetadata|FilesFolderMetadata|FilesDeletedMetadata), Error.<FilesRelocationError>>}\n */\nroutes.filesMove = function (arg) {\n  return this.request('files/move', arg, 'user', 'api', 'rpc');\n};\n\n/**\n * Move multiple files or folders to different locations at once in the user's\n * Dropbox. This route is 'all or nothing', which means if one entry fails, the\n * whole transaction will abort. This route will return job ID immediately and\n * do the async moving job in background. Please use move_batch/check to check\n * the job status.\n * @function Dropbox#filesMoveBatch\n * @arg {FilesRelocationBatchArg} arg - The request parameters.\n * @returns {Promise.<FilesRelocationBatchLaunch, Error.<void>>}\n */\nroutes.filesMoveBatch = function (arg) {\n  return this.request('files/move_batch', arg, 'user', 'api', 'rpc');\n};\n\n/**\n * Returns the status of an asynchronous job for move_batch. If success, it\n * returns list of results for each entry.\n * @function Dropbox#filesMoveBatchCheck\n * @arg {AsyncPollArg} arg - The request parameters.\n * @returns {Promise.<FilesRelocationBatchJobStatus, Error.<AsyncPollError>>}\n */\nroutes.filesMoveBatchCheck = function (arg) {\n  return this.request('files/move_batch/check', arg, 'user', 'api', 'rpc');\n};\n\n/**\n * Permanently delete the file or folder at a given path (see\n * https://www.dropbox.com/en/help/40). Note: This endpoint is only available\n * for Dropbox Business apps.\n * @function Dropbox#filesPermanentlyDelete\n * @arg {FilesDeleteArg} arg - The request parameters.\n * @returns {Promise.<void, Error.<FilesDeleteError>>}\n */\nroutes.filesPermanentlyDelete = function (arg) {\n  return this.request('files/permanently_delete', arg, 'user', 'api', 'rpc');\n};\n\n/**\n * Add custom properties to a file using a filled property template. See\n * properties/template/add to create new property templates.\n * @function Dropbox#filesPropertiesAdd\n * @arg {FilesPropertyGroupWithPath} arg - The request parameters.\n * @returns {Promise.<void, Error.<FilesAddPropertiesError>>}\n */\nroutes.filesPropertiesAdd = function (arg) {\n  return this.request('files/properties/add', arg, 'user', 'api', 'rpc');\n};\n\n/**\n * Overwrite custom properties from a specified template associated with a file.\n * @function Dropbox#filesPropertiesOverwrite\n * @arg {FilesPropertyGroupWithPath} arg - The request parameters.\n * @returns {Promise.<void, Error.<FilesInvalidPropertyGroupError>>}\n */\nroutes.filesPropertiesOverwrite = function (arg) {\n  return this.request('files/properties/overwrite', arg, 'user', 'api', 'rpc');\n};\n\n/**\n * Remove all custom properties from a specified template associated with a\n * file. To remove specific property key value pairs, see properties/update. To\n * update a property template, see properties/template/update. Property\n * templates can't be removed once created.\n * @function Dropbox#filesPropertiesRemove\n * @arg {FilesRemovePropertiesArg} arg - The request parameters.\n * @returns {Promise.<void, Error.<FilesRemovePropertiesError>>}\n */\nroutes.filesPropertiesRemove = function (arg) {\n  return this.request('files/properties/remove', arg, 'user', 'api', 'rpc');\n};\n\n/**\n * Get the schema for a specified template.\n * @function Dropbox#filesPropertiesTemplateGet\n * @arg {PropertiesGetPropertyTemplateArg} arg - The request parameters.\n * @returns {Promise.<PropertiesGetPropertyTemplateResult, Error.<PropertiesPropertyTemplateError>>}\n */\nroutes.filesPropertiesTemplateGet = function (arg) {\n  return this.request('files/properties/template/get', arg, 'user', 'api', 'rpc');\n};\n\n/**\n * Get the property template identifiers for a user. To get the schema of each\n * template use properties/template/get.\n * @function Dropbox#filesPropertiesTemplateList\n * @arg {void} arg - The request parameters.\n * @returns {Promise.<PropertiesListPropertyTemplateIds, Error.<PropertiesPropertyTemplateError>>}\n */\nroutes.filesPropertiesTemplateList = function (arg) {\n  return this.request('files/properties/template/list', arg, 'user', 'api', 'rpc');\n};\n\n/**\n * Add, update or remove custom properties from a specified template associated\n * with a file. Fields that already exist and not described in the request will\n * not be modified.\n * @function Dropbox#filesPropertiesUpdate\n * @arg {FilesUpdatePropertyGroupArg} arg - The request parameters.\n * @returns {Promise.<void, Error.<FilesUpdatePropertiesError>>}\n */\nroutes.filesPropertiesUpdate = function (arg) {\n  return this.request('files/properties/update', arg, 'user', 'api', 'rpc');\n};\n\n/**\n * Restore a file to a specific revision.\n * @function Dropbox#filesRestore\n * @arg {FilesRestoreArg} arg - The request parameters.\n * @returns {Promise.<FilesFileMetadata, Error.<FilesRestoreError>>}\n */\nroutes.filesRestore = function (arg) {\n  return this.request('files/restore', arg, 'user', 'api', 'rpc');\n};\n\n/**\n * Save a specified URL into a file in user's Dropbox. If the given path already\n * exists, the file will be renamed to avoid the conflict (e.g. myfile (1).txt).\n * @function Dropbox#filesSaveUrl\n * @arg {FilesSaveUrlArg} arg - The request parameters.\n * @returns {Promise.<FilesSaveUrlResult, Error.<FilesSaveUrlError>>}\n */\nroutes.filesSaveUrl = function (arg) {\n  return this.request('files/save_url', arg, 'user', 'api', 'rpc');\n};\n\n/**\n * Check the status of a save_url job.\n * @function Dropbox#filesSaveUrlCheckJobStatus\n * @arg {AsyncPollArg} arg - The request parameters.\n * @returns {Promise.<FilesSaveUrlJobStatus, Error.<AsyncPollError>>}\n */\nroutes.filesSaveUrlCheckJobStatus = function (arg) {\n  return this.request('files/save_url/check_job_status', arg, 'user', 'api', 'rpc');\n};\n\n/**\n * Searches for files and folders. Note: Recent changes may not immediately be\n * reflected in search results due to a short delay in indexing.\n * @function Dropbox#filesSearch\n * @arg {FilesSearchArg} arg - The request parameters.\n * @returns {Promise.<FilesSearchResult, Error.<FilesSearchError>>}\n */\nroutes.filesSearch = function (arg) {\n  return this.request('files/search', arg, 'user', 'api', 'rpc');\n};\n\n/**\n * Create a new file with the contents provided in the request. Do not use this\n * to upload a file larger than 150 MB. Instead, create an upload session with\n * upload_session/start.\n * @function Dropbox#filesUpload\n * @arg {FilesCommitInfo} arg - The request parameters.\n * @returns {Promise.<FilesFileMetadata, Error.<FilesUploadError>>}\n */\nroutes.filesUpload = function (arg) {\n  return this.request('files/upload', arg, 'user', 'content', 'upload');\n};\n\n/**\n * Append more data to an upload session. A single request should not upload\n * more than 150 MB of file contents.\n * @function Dropbox#filesUploadSessionAppend\n * @deprecated\n * @arg {FilesUploadSessionCursor} arg - The request parameters.\n * @returns {Promise.<void, Error.<FilesUploadSessionLookupError>>}\n */\nroutes.filesUploadSessionAppend = function (arg) {\n  return this.request('files/upload_session/append', arg, 'user', 'content', 'upload');\n};\n\n/**\n * Append more data to an upload session. When the parameter close is set, this\n * call will close the session. A single request should not upload more than 150\n * MB of file contents.\n * @function Dropbox#filesUploadSessionAppendV2\n * @arg {FilesUploadSessionAppendArg} arg - The request parameters.\n * @returns {Promise.<void, Error.<FilesUploadSessionLookupError>>}\n */\nroutes.filesUploadSessionAppendV2 = function (arg) {\n  return this.request('files/upload_session/append_v2', arg, 'user', 'content', 'upload');\n};\n\n/**\n * Finish an upload session and save the uploaded data to the given file path. A\n * single request should not upload more than 150 MB of file contents.\n * @function Dropbox#filesUploadSessionFinish\n * @arg {FilesUploadSessionFinishArg} arg - The request parameters.\n * @returns {Promise.<FilesFileMetadata, Error.<FilesUploadSessionFinishError>>}\n */\nroutes.filesUploadSessionFinish = function (arg) {\n  return this.request('files/upload_session/finish', arg, 'user', 'content', 'upload');\n};\n\n/**\n * This route helps you commit many files at once into a user's Dropbox. Use\n * upload_session/start and upload_session/append_v2 to upload file contents. We\n * recommend uploading many files in parallel to increase throughput. Once the\n * file contents have been uploaded, rather than calling upload_session/finish,\n * use this route to finish all your upload sessions in a single request.\n * UploadSessionStartArg.close or UploadSessionAppendArg.close needs to be true\n * for the last upload_session/start or upload_session/append_v2 call. This\n * route will return a job_id immediately and do the async commit job in\n * background. Use upload_session/finish_batch/check to check the job status.\n * For the same account, this route should be executed serially. That means you\n * should not start the next job before current job finishes. We allow up to\n * 1000 entries in a single request.\n * @function Dropbox#filesUploadSessionFinishBatch\n * @arg {FilesUploadSessionFinishBatchArg} arg - The request parameters.\n * @returns {Promise.<FilesUploadSessionFinishBatchLaunch, Error.<void>>}\n */\nroutes.filesUploadSessionFinishBatch = function (arg) {\n  return this.request('files/upload_session/finish_batch', arg, 'user', 'api', 'rpc');\n};\n\n/**\n * Returns the status of an asynchronous job for upload_session/finish_batch. If\n * success, it returns list of result for each entry.\n * @function Dropbox#filesUploadSessionFinishBatchCheck\n * @arg {AsyncPollArg} arg - The request parameters.\n * @returns {Promise.<FilesUploadSessionFinishBatchJobStatus, Error.<AsyncPollError>>}\n */\nroutes.filesUploadSessionFinishBatchCheck = function (arg) {\n  return this.request('files/upload_session/finish_batch/check', arg, 'user', 'api', 'rpc');\n};\n\n/**\n * Upload sessions allow you to upload a single file in one or more requests,\n * for example where the size of the file is greater than 150 MB.  This call\n * starts a new upload session with the given data. You can then use\n * upload_session/append_v2 to add more data and upload_session/finish to save\n * all the data to a file in Dropbox. A single request should not upload more\n * than 150 MB of file contents.\n * @function Dropbox#filesUploadSessionStart\n * @arg {FilesUploadSessionStartArg} arg - The request parameters.\n * @returns {Promise.<FilesUploadSessionStartResult, Error.<void>>}\n */\nroutes.filesUploadSessionStart = function (arg) {\n  return this.request('files/upload_session/start', arg, 'user', 'content', 'upload');\n};\n\n/**\n * Marks the given Paper doc as deleted. This operation is non-destructive and\n * the doc can be revived by the owner.  Note: This action can be performed only\n * by the doc owner.\n * @function Dropbox#paperDocsArchive\n * @arg {PaperRefPaperDoc} arg - The request parameters.\n * @returns {Promise.<void, Error.<PaperDocLookupError>>}\n */\nroutes.paperDocsArchive = function (arg) {\n  return this.request('paper/docs/archive', arg, 'user', 'api', 'rpc');\n};\n\n/**\n * Exports and downloads Paper doc either as HTML or markdown.\n * @function Dropbox#paperDocsDownload\n * @arg {PaperPaperDocExport} arg - The request parameters.\n * @returns {Promise.<PaperPaperDocExportResult, Error.<PaperDocLookupError>>}\n */\nroutes.paperDocsDownload = function (arg) {\n  return this.request('paper/docs/download', arg, 'user', 'api', 'download');\n};\n\n/**\n * Lists the users who are explicitly invited to the Paper folder in which the\n * Paper doc is contained. For private folders all users (including owner)\n * shared on the folder are listed and for team folders all non-team users\n * shared on the folder are returned.\n * @function Dropbox#paperDocsFolderUsersList\n * @arg {PaperListUsersOnFolderArgs} arg - The request parameters.\n * @returns {Promise.<PaperListUsersOnFolderResponse, Error.<PaperDocLookupError>>}\n */\nroutes.paperDocsFolderUsersList = function (arg) {\n  return this.request('paper/docs/folder_users/list', arg, 'user', 'api', 'rpc');\n};\n\n/**\n * Once a cursor has been retrieved from docs/folder_users/list, use this to\n * paginate through all users on the Paper folder.\n * @function Dropbox#paperDocsFolderUsersListContinue\n * @arg {PaperListUsersOnFolderContinueArgs} arg - The request parameters.\n * @returns {Promise.<PaperListUsersOnFolderResponse, Error.<PaperListUsersCursorError>>}\n */\nroutes.paperDocsFolderUsersListContinue = function (arg) {\n  return this.request('paper/docs/folder_users/list/continue', arg, 'user', 'api', 'rpc');\n};\n\n/**\n * Retrieves folder information for the given Paper doc. This includes:   -\n * folder sharing policy; permissions for subfolders are set by the top-level\n * folder.   - full 'filepath', i.e. the list of folders (both folderId and\n * folderName) from the root folder to the folder directly containing the Paper\n * doc.  Note: If the Paper doc is not in any folder (aka unfiled) the response\n * will be empty.\n * @function Dropbox#paperDocsGetFolderInfo\n * @arg {PaperRefPaperDoc} arg - The request parameters.\n * @returns {Promise.<PaperFoldersContainingPaperDoc, Error.<PaperDocLookupError>>}\n */\nroutes.paperDocsGetFolderInfo = function (arg) {\n  return this.request('paper/docs/get_folder_info', arg, 'user', 'api', 'rpc');\n};\n\n/**\n * Return the list of all Paper docs according to the argument specifications.\n * To iterate over through the full pagination, pass the cursor to\n * docs/list/continue.\n * @function Dropbox#paperDocsList\n * @arg {PaperListPaperDocsArgs} arg - The request parameters.\n * @returns {Promise.<PaperListPaperDocsResponse, Error.<void>>}\n */\nroutes.paperDocsList = function (arg) {\n  return this.request('paper/docs/list', arg, 'user', 'api', 'rpc');\n};\n\n/**\n * Once a cursor has been retrieved from docs/list, use this to paginate through\n * all Paper doc.\n * @function Dropbox#paperDocsListContinue\n * @arg {PaperListPaperDocsContinueArgs} arg - The request parameters.\n * @returns {Promise.<PaperListPaperDocsResponse, Error.<PaperListDocsCursorError>>}\n */\nroutes.paperDocsListContinue = function (arg) {\n  return this.request('paper/docs/list/continue', arg, 'user', 'api', 'rpc');\n};\n\n/**\n * Permanently deletes the given Paper doc. This operation is final as the doc\n * cannot be recovered.  Note: This action can be performed only by the doc\n * owner.\n * @function Dropbox#paperDocsPermanentlyDelete\n * @arg {PaperRefPaperDoc} arg - The request parameters.\n * @returns {Promise.<void, Error.<PaperDocLookupError>>}\n */\nroutes.paperDocsPermanentlyDelete = function (arg) {\n  return this.request('paper/docs/permanently_delete', arg, 'user', 'api', 'rpc');\n};\n\n/**\n * Gets the default sharing policy for the given Paper doc.\n * @function Dropbox#paperDocsSharingPolicyGet\n * @arg {PaperRefPaperDoc} arg - The request parameters.\n * @returns {Promise.<PaperSharingPolicy, Error.<PaperDocLookupError>>}\n */\nroutes.paperDocsSharingPolicyGet = function (arg) {\n  return this.request('paper/docs/sharing_policy/get', arg, 'user', 'api', 'rpc');\n};\n\n/**\n * Sets the default sharing policy for the given Paper doc. The default\n * 'team_sharing_policy' can be changed only by teams, omit this field for\n * personal accounts.  Note: 'public_sharing_policy' cannot be set to the value\n * 'disabled' because this setting can be changed only via the team admin\n * console.\n * @function Dropbox#paperDocsSharingPolicySet\n * @arg {PaperPaperDocSharingPolicy} arg - The request parameters.\n * @returns {Promise.<void, Error.<PaperDocLookupError>>}\n */\nroutes.paperDocsSharingPolicySet = function (arg) {\n  return this.request('paper/docs/sharing_policy/set', arg, 'user', 'api', 'rpc');\n};\n\n/**\n * Allows an owner or editor to add users to a Paper doc or change their\n * permissions using their email or Dropbox account id.  Note: The Doc owner's\n * permissions cannot be changed.\n * @function Dropbox#paperDocsUsersAdd\n * @arg {PaperAddPaperDocUser} arg - The request parameters.\n * @returns {Promise.<Array.<PaperAddPaperDocUserMemberResult>, Error.<PaperDocLookupError>>}\n */\nroutes.paperDocsUsersAdd = function (arg) {\n  return this.request('paper/docs/users/add', arg, 'user', 'api', 'rpc');\n};\n\n/**\n * Lists all users who visited the Paper doc or users with explicit access. This\n * call excludes users who have been removed. The list is sorted by the date of\n * the visit or the share date. The list will include both users, the explicitly\n * shared ones as well as those who came in using the Paper url link.\n * @function Dropbox#paperDocsUsersList\n * @arg {PaperListUsersOnPaperDocArgs} arg - The request parameters.\n * @returns {Promise.<PaperListUsersOnPaperDocResponse, Error.<PaperDocLookupError>>}\n */\nroutes.paperDocsUsersList = function (arg) {\n  return this.request('paper/docs/users/list', arg, 'user', 'api', 'rpc');\n};\n\n/**\n * Once a cursor has been retrieved from docs/users/list, use this to paginate\n * through all users on the Paper doc.\n * @function Dropbox#paperDocsUsersListContinue\n * @arg {PaperListUsersOnPaperDocContinueArgs} arg - The request parameters.\n * @returns {Promise.<PaperListUsersOnPaperDocResponse, Error.<PaperListUsersCursorError>>}\n */\nroutes.paperDocsUsersListContinue = function (arg) {\n  return this.request('paper/docs/users/list/continue', arg, 'user', 'api', 'rpc');\n};\n\n/**\n * Allows an owner or editor to remove users from a Paper doc using their email\n * or Dropbox account id.  Note: Doc owner cannot be removed.\n * @function Dropbox#paperDocsUsersRemove\n * @arg {PaperRemovePaperDocUser} arg - The request parameters.\n * @returns {Promise.<void, Error.<PaperDocLookupError>>}\n */\nroutes.paperDocsUsersRemove = function (arg) {\n  return this.request('paper/docs/users/remove', arg, 'user', 'api', 'rpc');\n};\n\n/**\n * Adds specified members to a file.\n * @function Dropbox#sharingAddFileMember\n * @arg {SharingAddFileMemberArgs} arg - The request parameters.\n * @returns {Promise.<Array.<SharingFileMemberActionResult>, Error.<SharingAddFileMemberError>>}\n */\nroutes.sharingAddFileMember = function (arg) {\n  return this.request('sharing/add_file_member', arg, 'user', 'api', 'rpc');\n};\n\n/**\n * Allows an owner or editor (if the ACL update policy allows) of a shared\n * folder to add another member. For the new member to get access to all the\n * functionality for this folder, you will need to call mount_folder on their\n * behalf. Apps must have full Dropbox access to use this endpoint.\n * @function Dropbox#sharingAddFolderMember\n * @arg {SharingAddFolderMemberArg} arg - The request parameters.\n * @returns {Promise.<void, Error.<SharingAddFolderMemberError>>}\n */\nroutes.sharingAddFolderMember = function (arg) {\n  return this.request('sharing/add_folder_member', arg, 'user', 'api', 'rpc');\n};\n\n/**\n * Identical to update_file_member but with less information returned.\n * @function Dropbox#sharingChangeFileMemberAccess\n * @deprecated\n * @arg {SharingChangeFileMemberAccessArgs} arg - The request parameters.\n * @returns {Promise.<SharingFileMemberActionResult, Error.<SharingFileMemberActionError>>}\n */\nroutes.sharingChangeFileMemberAccess = function (arg) {\n  return this.request('sharing/change_file_member_access', arg, 'user', 'api', 'rpc');\n};\n\n/**\n * Returns the status of an asynchronous job. Apps must have full Dropbox access\n * to use this endpoint.\n * @function Dropbox#sharingCheckJobStatus\n * @arg {AsyncPollArg} arg - The request parameters.\n * @returns {Promise.<SharingJobStatus, Error.<AsyncPollError>>}\n */\nroutes.sharingCheckJobStatus = function (arg) {\n  return this.request('sharing/check_job_status', arg, 'user', 'api', 'rpc');\n};\n\n/**\n * Returns the status of an asynchronous job for sharing a folder. Apps must\n * have full Dropbox access to use this endpoint.\n * @function Dropbox#sharingCheckRemoveMemberJobStatus\n * @arg {AsyncPollArg} arg - The request parameters.\n * @returns {Promise.<SharingRemoveMemberJobStatus, Error.<AsyncPollError>>}\n */\nroutes.sharingCheckRemoveMemberJobStatus = function (arg) {\n  return this.request('sharing/check_remove_member_job_status', arg, 'user', 'api', 'rpc');\n};\n\n/**\n * Returns the status of an asynchronous job for sharing a folder. Apps must\n * have full Dropbox access to use this endpoint.\n * @function Dropbox#sharingCheckShareJobStatus\n * @arg {AsyncPollArg} arg - The request parameters.\n * @returns {Promise.<SharingShareFolderJobStatus, Error.<AsyncPollError>>}\n */\nroutes.sharingCheckShareJobStatus = function (arg) {\n  return this.request('sharing/check_share_job_status', arg, 'user', 'api', 'rpc');\n};\n\n/**\n * Create a shared link. If a shared link already exists for the given path,\n * that link is returned. Note that in the returned PathLinkMetadata, the\n * PathLinkMetadata.url field is the shortened URL if\n * CreateSharedLinkArg.short_url argument is set to true. Previously, it was\n * technically possible to break a shared link by moving or renaming the\n * corresponding file or folder. In the future, this will no longer be the case,\n * so your app shouldn't rely on this behavior. Instead, if your app needs to\n * revoke a shared link, use revoke_shared_link.\n * @function Dropbox#sharingCreateSharedLink\n * @deprecated\n * @arg {SharingCreateSharedLinkArg} arg - The request parameters.\n * @returns {Promise.<SharingPathLinkMetadata, Error.<SharingCreateSharedLinkError>>}\n */\nroutes.sharingCreateSharedLink = function (arg) {\n  return this.request('sharing/create_shared_link', arg, 'user', 'api', 'rpc');\n};\n\n/**\n * Create a shared link with custom settings. If no settings are given then the\n * default visibility is RequestedVisibility.public (The resolved visibility,\n * though, may depend on other aspects such as team and shared folder settings).\n * @function Dropbox#sharingCreateSharedLinkWithSettings\n * @arg {SharingCreateSharedLinkWithSettingsArg} arg - The request parameters.\n * @returns {Promise.<(SharingFileLinkMetadata|SharingFolderLinkMetadata|SharingSharedLinkMetadata), Error.<SharingCreateSharedLinkWithSettingsError>>}\n */\nroutes.sharingCreateSharedLinkWithSettings = function (arg) {\n  return this.request('sharing/create_shared_link_with_settings', arg, 'user', 'api', 'rpc');\n};\n\n/**\n * Returns shared file metadata.\n * @function Dropbox#sharingGetFileMetadata\n * @arg {SharingGetFileMetadataArg} arg - The request parameters.\n * @returns {Promise.<SharingSharedFileMetadata, Error.<SharingGetFileMetadataError>>}\n */\nroutes.sharingGetFileMetadata = function (arg) {\n  return this.request('sharing/get_file_metadata', arg, 'user', 'api', 'rpc');\n};\n\n/**\n * Returns shared file metadata.\n * @function Dropbox#sharingGetFileMetadataBatch\n * @arg {SharingGetFileMetadataBatchArg} arg - The request parameters.\n * @returns {Promise.<Array.<SharingGetFileMetadataBatchResult>, Error.<SharingSharingUserError>>}\n */\nroutes.sharingGetFileMetadataBatch = function (arg) {\n  return this.request('sharing/get_file_metadata/batch', arg, 'user', 'api', 'rpc');\n};\n\n/**\n * Returns shared folder metadata by its folder ID. Apps must have full Dropbox\n * access to use this endpoint.\n * @function Dropbox#sharingGetFolderMetadata\n * @arg {SharingGetMetadataArgs} arg - The request parameters.\n * @returns {Promise.<SharingSharedFolderMetadata, Error.<SharingSharedFolderAccessError>>}\n */\nroutes.sharingGetFolderMetadata = function (arg) {\n  return this.request('sharing/get_folder_metadata', arg, 'user', 'api', 'rpc');\n};\n\n/**\n * Download the shared link's file from a user's Dropbox.\n * @function Dropbox#sharingGetSharedLinkFile\n * @arg {Object} arg - The request parameters.\n * @returns {Promise.<(SharingFileLinkMetadata|SharingFolderLinkMetadata|SharingSharedLinkMetadata), Error.<SharingGetSharedLinkFileError>>}\n */\nroutes.sharingGetSharedLinkFile = function (arg) {\n  return this.request('sharing/get_shared_link_file', arg, 'user', 'content', 'download');\n};\n\n/**\n * Get the shared link's metadata.\n * @function Dropbox#sharingGetSharedLinkMetadata\n * @arg {SharingGetSharedLinkMetadataArg} arg - The request parameters.\n * @returns {Promise.<(SharingFileLinkMetadata|SharingFolderLinkMetadata|SharingSharedLinkMetadata), Error.<SharingSharedLinkError>>}\n */\nroutes.sharingGetSharedLinkMetadata = function (arg) {\n  return this.request('sharing/get_shared_link_metadata', arg, 'user', 'api', 'rpc');\n};\n\n/**\n * Returns a list of LinkMetadata objects for this user, including collection\n * links. If no path is given, returns a list of all shared links for the\n * current user, including collection links. If a non-empty path is given,\n * returns a list of all shared links that allow access to the given path.\n * Collection links are never returned in this case. Note that the url field in\n * the response is never the shortened URL.\n * @function Dropbox#sharingGetSharedLinks\n * @deprecated\n * @arg {SharingGetSharedLinksArg} arg - The request parameters.\n * @returns {Promise.<SharingGetSharedLinksResult, Error.<SharingGetSharedLinksError>>}\n */\nroutes.sharingGetSharedLinks = function (arg) {\n  return this.request('sharing/get_shared_links', arg, 'user', 'api', 'rpc');\n};\n\n/**\n * Use to obtain the members who have been invited to a file, both inherited and\n * uninherited members.\n * @function Dropbox#sharingListFileMembers\n * @arg {SharingListFileMembersArg} arg - The request parameters.\n * @returns {Promise.<SharingSharedFileMembers, Error.<SharingListFileMembersError>>}\n */\nroutes.sharingListFileMembers = function (arg) {\n  return this.request('sharing/list_file_members', arg, 'user', 'api', 'rpc');\n};\n\n/**\n * Get members of multiple files at once. The arguments to this route are more\n * limited, and the limit on query result size per file is more strict. To\n * customize the results more, use the individual file endpoint. Inherited users\n * and groups are not included in the result, and permissions are not returned\n * for this endpoint.\n * @function Dropbox#sharingListFileMembersBatch\n * @arg {SharingListFileMembersBatchArg} arg - The request parameters.\n * @returns {Promise.<Array.<SharingListFileMembersBatchResult>, Error.<SharingSharingUserError>>}\n */\nroutes.sharingListFileMembersBatch = function (arg) {\n  return this.request('sharing/list_file_members/batch', arg, 'user', 'api', 'rpc');\n};\n\n/**\n * Once a cursor has been retrieved from list_file_members or\n * list_file_members/batch, use this to paginate through all shared file\n * members.\n * @function Dropbox#sharingListFileMembersContinue\n * @arg {SharingListFileMembersContinueArg} arg - The request parameters.\n * @returns {Promise.<SharingSharedFileMembers, Error.<SharingListFileMembersContinueError>>}\n */\nroutes.sharingListFileMembersContinue = function (arg) {\n  return this.request('sharing/list_file_members/continue', arg, 'user', 'api', 'rpc');\n};\n\n/**\n * Returns shared folder membership by its folder ID. Apps must have full\n * Dropbox access to use this endpoint.\n * @function Dropbox#sharingListFolderMembers\n * @arg {SharingListFolderMembersArgs} arg - The request parameters.\n * @returns {Promise.<SharingSharedFolderMembers, Error.<SharingSharedFolderAccessError>>}\n */\nroutes.sharingListFolderMembers = function (arg) {\n  return this.request('sharing/list_folder_members', arg, 'user', 'api', 'rpc');\n};\n\n/**\n * Once a cursor has been retrieved from list_folder_members, use this to\n * paginate through all shared folder members. Apps must have full Dropbox\n * access to use this endpoint.\n * @function Dropbox#sharingListFolderMembersContinue\n * @arg {SharingListFolderMembersContinueArg} arg - The request parameters.\n * @returns {Promise.<SharingSharedFolderMembers, Error.<SharingListFolderMembersContinueError>>}\n */\nroutes.sharingListFolderMembersContinue = function (arg) {\n  return this.request('sharing/list_folder_members/continue', arg, 'user', 'api', 'rpc');\n};\n\n/**\n * Return the list of all shared folders the current user has access to. Apps\n * must have full Dropbox access to use this endpoint.\n * @function Dropbox#sharingListFolders\n * @arg {SharingListFoldersArgs} arg - The request parameters.\n * @returns {Promise.<SharingListFoldersResult, Error.<void>>}\n */\nroutes.sharingListFolders = function (arg) {\n  return this.request('sharing/list_folders', arg, 'user', 'api', 'rpc');\n};\n\n/**\n * Once a cursor has been retrieved from list_folders, use this to paginate\n * through all shared folders. The cursor must come from a previous call to\n * list_folders or list_folders/continue. Apps must have full Dropbox access to\n * use this endpoint.\n * @function Dropbox#sharingListFoldersContinue\n * @arg {SharingListFoldersContinueArg} arg - The request parameters.\n * @returns {Promise.<SharingListFoldersResult, Error.<SharingListFoldersContinueError>>}\n */\nroutes.sharingListFoldersContinue = function (arg) {\n  return this.request('sharing/list_folders/continue', arg, 'user', 'api', 'rpc');\n};\n\n/**\n * Return the list of all shared folders the current user can mount or unmount.\n * Apps must have full Dropbox access to use this endpoint.\n * @function Dropbox#sharingListMountableFolders\n * @arg {SharingListFoldersArgs} arg - The request parameters.\n * @returns {Promise.<SharingListFoldersResult, Error.<void>>}\n */\nroutes.sharingListMountableFolders = function (arg) {\n  return this.request('sharing/list_mountable_folders', arg, 'user', 'api', 'rpc');\n};\n\n/**\n * Once a cursor has been retrieved from list_mountable_folders, use this to\n * paginate through all mountable shared folders. The cursor must come from a\n * previous call to list_mountable_folders or list_mountable_folders/continue.\n * Apps must have full Dropbox access to use this endpoint.\n * @function Dropbox#sharingListMountableFoldersContinue\n * @arg {SharingListFoldersContinueArg} arg - The request parameters.\n * @returns {Promise.<SharingListFoldersResult, Error.<SharingListFoldersContinueError>>}\n */\nroutes.sharingListMountableFoldersContinue = function (arg) {\n  return this.request('sharing/list_mountable_folders/continue', arg, 'user', 'api', 'rpc');\n};\n\n/**\n * Returns a list of all files shared with current user.  Does not include files\n * the user has received via shared folders, and does  not include unclaimed\n * invitations.\n * @function Dropbox#sharingListReceivedFiles\n * @arg {SharingListFilesArg} arg - The request parameters.\n * @returns {Promise.<SharingListFilesResult, Error.<SharingSharingUserError>>}\n */\nroutes.sharingListReceivedFiles = function (arg) {\n  return this.request('sharing/list_received_files', arg, 'user', 'api', 'rpc');\n};\n\n/**\n * Get more results with a cursor from list_received_files.\n * @function Dropbox#sharingListReceivedFilesContinue\n * @arg {SharingListFilesContinueArg} arg - The request parameters.\n * @returns {Promise.<SharingListFilesResult, Error.<SharingListFilesContinueError>>}\n */\nroutes.sharingListReceivedFilesContinue = function (arg) {\n  return this.request('sharing/list_received_files/continue', arg, 'user', 'api', 'rpc');\n};\n\n/**\n * List shared links of this user. If no path is given, returns a list of all\n * shared links for the current user. If a non-empty path is given, returns a\n * list of all shared links that allow access to the given path - direct links\n * to the given path and links to parent folders of the given path. Links to\n * parent folders can be suppressed by setting direct_only to true.\n * @function Dropbox#sharingListSharedLinks\n * @arg {SharingListSharedLinksArg} arg - The request parameters.\n * @returns {Promise.<SharingListSharedLinksResult, Error.<SharingListSharedLinksError>>}\n */\nroutes.sharingListSharedLinks = function (arg) {\n  return this.request('sharing/list_shared_links', arg, 'user', 'api', 'rpc');\n};\n\n/**\n * Modify the shared link's settings. If the requested visibility conflict with\n * the shared links policy of the team or the shared folder (in case the linked\n * file is part of a shared folder) then the LinkPermissions.resolved_visibility\n * of the returned SharedLinkMetadata will reflect the actual visibility of the\n * shared link and the LinkPermissions.requested_visibility will reflect the\n * requested visibility.\n * @function Dropbox#sharingModifySharedLinkSettings\n * @arg {SharingModifySharedLinkSettingsArgs} arg - The request parameters.\n * @returns {Promise.<(SharingFileLinkMetadata|SharingFolderLinkMetadata|SharingSharedLinkMetadata), Error.<SharingModifySharedLinkSettingsError>>}\n */\nroutes.sharingModifySharedLinkSettings = function (arg) {\n  return this.request('sharing/modify_shared_link_settings', arg, 'user', 'api', 'rpc');\n};\n\n/**\n * The current user mounts the designated folder. Mount a shared folder for a\n * user after they have been added as a member. Once mounted, the shared folder\n * will appear in their Dropbox. Apps must have full Dropbox access to use this\n * endpoint.\n * @function Dropbox#sharingMountFolder\n * @arg {SharingMountFolderArg} arg - The request parameters.\n * @returns {Promise.<SharingSharedFolderMetadata, Error.<SharingMountFolderError>>}\n */\nroutes.sharingMountFolder = function (arg) {\n  return this.request('sharing/mount_folder', arg, 'user', 'api', 'rpc');\n};\n\n/**\n * The current user relinquishes their membership in the designated file. Note\n * that the current user may still have inherited access to this file through\n * the parent folder. Apps must have full Dropbox access to use this endpoint.\n * @function Dropbox#sharingRelinquishFileMembership\n * @arg {SharingRelinquishFileMembershipArg} arg - The request parameters.\n * @returns {Promise.<void, Error.<SharingRelinquishFileMembershipError>>}\n */\nroutes.sharingRelinquishFileMembership = function (arg) {\n  return this.request('sharing/relinquish_file_membership', arg, 'user', 'api', 'rpc');\n};\n\n/**\n * The current user relinquishes their membership in the designated shared\n * folder and will no longer have access to the folder.  A folder owner cannot\n * relinquish membership in their own folder. This will run synchronously if\n * leave_a_copy is false, and asynchronously if leave_a_copy is true. Apps must\n * have full Dropbox access to use this endpoint.\n * @function Dropbox#sharingRelinquishFolderMembership\n * @arg {SharingRelinquishFolderMembershipArg} arg - The request parameters.\n * @returns {Promise.<AsyncLaunchEmptyResult, Error.<SharingRelinquishFolderMembershipError>>}\n */\nroutes.sharingRelinquishFolderMembership = function (arg) {\n  return this.request('sharing/relinquish_folder_membership', arg, 'user', 'api', 'rpc');\n};\n\n/**\n * Identical to remove_file_member_2 but with less information returned.\n * @function Dropbox#sharingRemoveFileMember\n * @deprecated\n * @arg {SharingRemoveFileMemberArg} arg - The request parameters.\n * @returns {Promise.<SharingFileMemberActionIndividualResult, Error.<SharingRemoveFileMemberError>>}\n */\nroutes.sharingRemoveFileMember = function (arg) {\n  return this.request('sharing/remove_file_member', arg, 'user', 'api', 'rpc');\n};\n\n/**\n * Removes a specified member from the file.\n * @function Dropbox#sharingRemoveFileMember2\n * @arg {SharingRemoveFileMemberArg} arg - The request parameters.\n * @returns {Promise.<SharingFileMemberRemoveActionResult, Error.<SharingRemoveFileMemberError>>}\n */\nroutes.sharingRemoveFileMember2 = function (arg) {\n  return this.request('sharing/remove_file_member_2', arg, 'user', 'api', 'rpc');\n};\n\n/**\n * Allows an owner or editor (if the ACL update policy allows) of a shared\n * folder to remove another member. Apps must have full Dropbox access to use\n * this endpoint.\n * @function Dropbox#sharingRemoveFolderMember\n * @arg {SharingRemoveFolderMemberArg} arg - The request parameters.\n * @returns {Promise.<AsyncLaunchResultBase, Error.<SharingRemoveFolderMemberError>>}\n */\nroutes.sharingRemoveFolderMember = function (arg) {\n  return this.request('sharing/remove_folder_member', arg, 'user', 'api', 'rpc');\n};\n\n/**\n * Revoke a shared link. Note that even after revoking a shared link to a file,\n * the file may be accessible if there are shared links leading to any of the\n * file parent folders. To list all shared links that enable access to a\n * specific file, you can use the list_shared_links with the file as the\n * ListSharedLinksArg.path argument.\n * @function Dropbox#sharingRevokeSharedLink\n * @arg {SharingRevokeSharedLinkArg} arg - The request parameters.\n * @returns {Promise.<void, Error.<SharingRevokeSharedLinkError>>}\n */\nroutes.sharingRevokeSharedLink = function (arg) {\n  return this.request('sharing/revoke_shared_link', arg, 'user', 'api', 'rpc');\n};\n\n/**\n * Share a folder with collaborators. Most sharing will be completed\n * synchronously. Large folders will be completed asynchronously. To make\n * testing the async case repeatable, set `ShareFolderArg.force_async`. If a\n * ShareFolderLaunch.async_job_id is returned, you'll need to call\n * check_share_job_status until the action completes to get the metadata for the\n * folder. Apps must have full Dropbox access to use this endpoint.\n * @function Dropbox#sharingShareFolder\n * @arg {SharingShareFolderArg} arg - The request parameters.\n * @returns {Promise.<SharingShareFolderLaunch, Error.<SharingShareFolderError>>}\n */\nroutes.sharingShareFolder = function (arg) {\n  return this.request('sharing/share_folder', arg, 'user', 'api', 'rpc');\n};\n\n/**\n * Transfer ownership of a shared folder to a member of the shared folder. User\n * must have AccessLevel.owner access to the shared folder to perform a\n * transfer. Apps must have full Dropbox access to use this endpoint.\n * @function Dropbox#sharingTransferFolder\n * @arg {SharingTransferFolderArg} arg - The request parameters.\n * @returns {Promise.<void, Error.<SharingTransferFolderError>>}\n */\nroutes.sharingTransferFolder = function (arg) {\n  return this.request('sharing/transfer_folder', arg, 'user', 'api', 'rpc');\n};\n\n/**\n * The current user unmounts the designated folder. They can re-mount the folder\n * at a later time using mount_folder. Apps must have full Dropbox access to use\n * this endpoint.\n * @function Dropbox#sharingUnmountFolder\n * @arg {SharingUnmountFolderArg} arg - The request parameters.\n * @returns {Promise.<void, Error.<SharingUnmountFolderError>>}\n */\nroutes.sharingUnmountFolder = function (arg) {\n  return this.request('sharing/unmount_folder', arg, 'user', 'api', 'rpc');\n};\n\n/**\n * Remove all members from this file. Does not remove inherited members.\n * @function Dropbox#sharingUnshareFile\n * @arg {SharingUnshareFileArg} arg - The request parameters.\n * @returns {Promise.<void, Error.<SharingUnshareFileError>>}\n */\nroutes.sharingUnshareFile = function (arg) {\n  return this.request('sharing/unshare_file', arg, 'user', 'api', 'rpc');\n};\n\n/**\n * Allows a shared folder owner to unshare the folder. You'll need to call\n * check_job_status to determine if the action has completed successfully. Apps\n * must have full Dropbox access to use this endpoint.\n * @function Dropbox#sharingUnshareFolder\n * @arg {SharingUnshareFolderArg} arg - The request parameters.\n * @returns {Promise.<AsyncLaunchEmptyResult, Error.<SharingUnshareFolderError>>}\n */\nroutes.sharingUnshareFolder = function (arg) {\n  return this.request('sharing/unshare_folder', arg, 'user', 'api', 'rpc');\n};\n\n/**\n * Changes a member's access on a shared file.\n * @function Dropbox#sharingUpdateFileMember\n * @arg {SharingUpdateFileMemberArgs} arg - The request parameters.\n * @returns {Promise.<SharingMemberAccessLevelResult, Error.<SharingFileMemberActionError>>}\n */\nroutes.sharingUpdateFileMember = function (arg) {\n  return this.request('sharing/update_file_member', arg, 'user', 'api', 'rpc');\n};\n\n/**\n * Allows an owner or editor of a shared folder to update another member's\n * permissions. Apps must have full Dropbox access to use this endpoint.\n * @function Dropbox#sharingUpdateFolderMember\n * @arg {SharingUpdateFolderMemberArg} arg - The request parameters.\n * @returns {Promise.<SharingMemberAccessLevelResult, Error.<SharingUpdateFolderMemberError>>}\n */\nroutes.sharingUpdateFolderMember = function (arg) {\n  return this.request('sharing/update_folder_member', arg, 'user', 'api', 'rpc');\n};\n\n/**\n * Update the sharing policies for a shared folder. User must have\n * AccessLevel.owner access to the shared folder to update its policies. Apps\n * must have full Dropbox access to use this endpoint.\n * @function Dropbox#sharingUpdateFolderPolicy\n * @arg {SharingUpdateFolderPolicyArg} arg - The request parameters.\n * @returns {Promise.<SharingSharedFolderMetadata, Error.<SharingUpdateFolderPolicyError>>}\n */\nroutes.sharingUpdateFolderPolicy = function (arg) {\n  return this.request('sharing/update_folder_policy', arg, 'user', 'api', 'rpc');\n};\n\n/**\n * Get information about a user's account.\n * @function Dropbox#usersGetAccount\n * @arg {UsersGetAccountArg} arg - The request parameters.\n * @returns {Promise.<UsersBasicAccount, Error.<UsersGetAccountError>>}\n */\nroutes.usersGetAccount = function (arg) {\n  return this.request('users/get_account', arg, 'user', 'api', 'rpc');\n};\n\n/**\n * Get information about multiple user accounts.  At most 300 accounts may be\n * queried per request.\n * @function Dropbox#usersGetAccountBatch\n * @arg {UsersGetAccountBatchArg} arg - The request parameters.\n * @returns {Promise.<Object, Error.<UsersGetAccountBatchError>>}\n */\nroutes.usersGetAccountBatch = function (arg) {\n  return this.request('users/get_account_batch', arg, 'user', 'api', 'rpc');\n};\n\n/**\n * Get information about the current user's account.\n * @function Dropbox#usersGetCurrentAccount\n * @arg {void} arg - The request parameters.\n * @returns {Promise.<UsersFullAccount, Error.<void>>}\n */\nroutes.usersGetCurrentAccount = function (arg) {\n  return this.request('users/get_current_account', arg, 'user', 'api', 'rpc');\n};\n\n/**\n * Get the space usage information for the current user's account.\n * @function Dropbox#usersGetSpaceUsage\n * @arg {void} arg - The request parameters.\n * @returns {Promise.<UsersSpaceUsage, Error.<void>>}\n */\nroutes.usersGetSpaceUsage = function (arg) {\n  return this.request('users/get_space_usage', arg, 'user', 'api', 'rpc');\n};\n\nmodule.exports = routes;\n","/home/travis/build/npmtest/node-npmtest-dropbox/node_modules/dropbox/src/download-request.js":"var request = require('superagent');\nvar Promise = require('es6-promise').Promise;\nvar getBaseURL = require('./get-base-url');\nvar httpHeaderSafeJson = require('./http-header-safe-json');\n\nvar buildCustomError;\nvar downloadRequest;\nvar nodeBinaryParser;\n\n// Register a handler that will instruct superagent how to parse the response\nrequest.parse['application/octect-stream'] = function (obj) {\n  return obj;\n};\n\n// This doesn't match what was spec'd in paper doc yet\nbuildCustomError = function (error, response) {\n  return {\n    status: error.status,\n    error: (response ? response.text : null) || error.toString(),\n    response: response\n  };\n};\n\nnodeBinaryParser = function (res, done) {\n  res.text = '';\n  res.setEncoding('binary');\n  res.on('data', function (chunk) { res.text += chunk; });\n  res.on('end', function () {\n    done();\n  });\n};\n\ndownloadRequest = function (path, args, auth, host, accessToken, selectUser) {\n  if (auth !== 'user') {\n    throw new Error('Unexpected auth type: ' + auth);\n  }\n\n  var promiseFunction = function (resolve, reject) {\n    var apiRequest;\n\n    function success(data) {\n      if (resolve) {\n        resolve(data);\n      }\n    }\n\n    function failure(error) {\n      if (reject) {\n        reject(error);\n      }\n    }\n\n    function responseHandler(error, response) {\n      var data;\n      if (error) {\n        failure(buildCustomError(error, response));\n      } else {\n        // In the browser, the file is passed as a blob and in node the file is\n        // passed as a string of binary data.\n        data = JSON.parse(response.headers['dropbox-api-result']);\n        if (response.xhr) {\n          data.fileBlob = response.xhr.response;\n        } else {\n          data.fileBinary = response.res.text;\n        }\n        success(data);\n      }\n    }\n\n    apiRequest = request.post(getBaseURL(host) + path)\n      .set('Authorization', 'Bearer ' + accessToken)\n      .set('Dropbox-API-Arg', httpHeaderSafeJson(args))\n      .on('request', function () {\n        if (this.xhr) {\n          this.xhr.responseType = 'blob';\n        }\n      });\n\n    if (selectUser) {\n      apiRequest = apiRequest.set('Dropbox-API-Select-User', selectUser);\n    }\n\n    // Apply the node binary parser to the response if executing in node\n    if (typeof window === 'undefined') {\n      apiRequest\n        .buffer(true)\n        .parse(nodeBinaryParser)\n        .end(responseHandler);\n    } else {\n      apiRequest.end(responseHandler);\n    }\n  };\n\n  return new Promise(promiseFunction);\n};\n\nmodule.exports = downloadRequest;\n","/home/travis/build/npmtest/node-npmtest-dropbox/node_modules/dropbox/src/get-base-url.js":"function getBaseURL(host) {\n  return 'https://' + host + '.dropboxapi.com/2/';\n}\n\nmodule.exports = getBaseURL;\n","/home/travis/build/npmtest/node-npmtest-dropbox/node_modules/dropbox/src/http-header-safe-json.js":"// source https://www.dropboxforum.com/t5/API-support/HTTP-header-quot-Dropbox-API-Arg-quot-could-not-decode-input-as/m-p/173823/highlight/true#M6786\nvar charsToEncode = /[\\u007f-\\uffff]/g;\n\nfunction httpHeaderSafeJson(args) {\n  return JSON.stringify(args).replace(charsToEncode, function (c) {\n    return '\\\\u' + ('000' + c.charCodeAt(0).toString(16)).slice(-4);\n  });\n}\n\nmodule.exports = httpHeaderSafeJson;\n","/home/travis/build/npmtest/node-npmtest-dropbox/node_modules/dropbox/src/routes-team.js":"// Auto-generated by Stone, do not modify.\nvar routes = {};\n\n/**\n * List all device sessions of a team's member.\n * @function DropboxTeam#teamDevicesListMemberDevices\n * @arg {TeamListMemberDevicesArg} arg - The request parameters.\n * @returns {Promise.<TeamListMemberDevicesResult, Error.<TeamListMemberDevicesError>>}\n */\nroutes.teamDevicesListMemberDevices = function (arg) {\n  return this.request('team/devices/list_member_devices', arg, 'team', 'api', 'rpc');\n};\n\n/**\n * List all device sessions of a team.\n * @function DropboxTeam#teamDevicesListMembersDevices\n * @arg {TeamListMembersDevicesArg} arg - The request parameters.\n * @returns {Promise.<TeamListMembersDevicesResult, Error.<TeamListMembersDevicesError>>}\n */\nroutes.teamDevicesListMembersDevices = function (arg) {\n  return this.request('team/devices/list_members_devices', arg, 'team', 'api', 'rpc');\n};\n\n/**\n * List all device sessions of a team.\n * @function DropboxTeam#teamDevicesListTeamDevices\n * @deprecated\n * @arg {TeamListTeamDevicesArg} arg - The request parameters.\n * @returns {Promise.<TeamListTeamDevicesResult, Error.<TeamListTeamDevicesError>>}\n */\nroutes.teamDevicesListTeamDevices = function (arg) {\n  return this.request('team/devices/list_team_devices', arg, 'team', 'api', 'rpc');\n};\n\n/**\n * Revoke a device session of a team's member\n * @function DropboxTeam#teamDevicesRevokeDeviceSession\n * @arg {TeamRevokeDeviceSessionArg} arg - The request parameters.\n * @returns {Promise.<void, Error.<TeamRevokeDeviceSessionError>>}\n */\nroutes.teamDevicesRevokeDeviceSession = function (arg) {\n  return this.request('team/devices/revoke_device_session', arg, 'team', 'api', 'rpc');\n};\n\n/**\n * Revoke a list of device sessions of team members\n * @function DropboxTeam#teamDevicesRevokeDeviceSessionBatch\n * @arg {TeamRevokeDeviceSessionBatchArg} arg - The request parameters.\n * @returns {Promise.<TeamRevokeDeviceSessionBatchResult, Error.<TeamRevokeDeviceSessionBatchError>>}\n */\nroutes.teamDevicesRevokeDeviceSessionBatch = function (arg) {\n  return this.request('team/devices/revoke_device_session_batch', arg, 'team', 'api', 'rpc');\n};\n\n/**\n * Retrieves information about a team.\n * @function DropboxTeam#teamGetInfo\n * @arg {void} arg - The request parameters.\n * @returns {Promise.<TeamTeamGetInfoResult, Error.<void>>}\n */\nroutes.teamGetInfo = function (arg) {\n  return this.request('team/get_info', arg, 'team', 'api', 'rpc');\n};\n\n/**\n * Creates a new, empty group, with a requested name. Permission : Team member\n * management.\n * @function DropboxTeam#teamGroupsCreate\n * @arg {TeamGroupCreateArg} arg - The request parameters.\n * @returns {Promise.<TeamGroupFullInfo, Error.<TeamGroupCreateError>>}\n */\nroutes.teamGroupsCreate = function (arg) {\n  return this.request('team/groups/create', arg, 'team', 'api', 'rpc');\n};\n\n/**\n * Deletes a group. The group is deleted immediately. However the revoking of\n * group-owned resources may take additional time. Use the groups/job_status/get\n * to determine whether this process has completed. Permission : Team member\n * management.\n * @function DropboxTeam#teamGroupsDelete\n * @arg {TeamGroupSelector} arg - The request parameters.\n * @returns {Promise.<AsyncLaunchEmptyResult, Error.<TeamGroupDeleteError>>}\n */\nroutes.teamGroupsDelete = function (arg) {\n  return this.request('team/groups/delete', arg, 'team', 'api', 'rpc');\n};\n\n/**\n * Retrieves information about one or more groups. Note that the optional field\n * GroupFullInfo.members is not returned for system-managed groups. Permission :\n * Team Information.\n * @function DropboxTeam#teamGroupsGetInfo\n * @arg {TeamGroupsSelector} arg - The request parameters.\n * @returns {Promise.<Object, Error.<TeamGroupsGetInfoError>>}\n */\nroutes.teamGroupsGetInfo = function (arg) {\n  return this.request('team/groups/get_info', arg, 'team', 'api', 'rpc');\n};\n\n/**\n * Once an async_job_id is returned from groups/delete, groups/members/add , or\n * groups/members/remove use this method to poll the status of granting/revoking\n * group members' access to group-owned resources. Permission : Team member\n * management.\n * @function DropboxTeam#teamGroupsJobStatusGet\n * @arg {AsyncPollArg} arg - The request parameters.\n * @returns {Promise.<AsyncPollEmptyResult, Error.<TeamGroupsPollError>>}\n */\nroutes.teamGroupsJobStatusGet = function (arg) {\n  return this.request('team/groups/job_status/get', arg, 'team', 'api', 'rpc');\n};\n\n/**\n * Lists groups on a team. Permission : Team Information.\n * @function DropboxTeam#teamGroupsList\n * @arg {TeamGroupsListArg} arg - The request parameters.\n * @returns {Promise.<TeamGroupsListResult, Error.<void>>}\n */\nroutes.teamGroupsList = function (arg) {\n  return this.request('team/groups/list', arg, 'team', 'api', 'rpc');\n};\n\n/**\n * Once a cursor has been retrieved from groups/list, use this to paginate\n * through all groups. Permission : Team Information.\n * @function DropboxTeam#teamGroupsListContinue\n * @arg {TeamGroupsListContinueArg} arg - The request parameters.\n * @returns {Promise.<TeamGroupsListResult, Error.<TeamGroupsListContinueError>>}\n */\nroutes.teamGroupsListContinue = function (arg) {\n  return this.request('team/groups/list/continue', arg, 'team', 'api', 'rpc');\n};\n\n/**\n * Adds members to a group. The members are added immediately. However the\n * granting of group-owned resources may take additional time. Use the\n * groups/job_status/get to determine whether this process has completed.\n * Permission : Team member management.\n * @function DropboxTeam#teamGroupsMembersAdd\n * @arg {TeamGroupMembersAddArg} arg - The request parameters.\n * @returns {Promise.<TeamGroupMembersChangeResult, Error.<TeamGroupMembersAddError>>}\n */\nroutes.teamGroupsMembersAdd = function (arg) {\n  return this.request('team/groups/members/add', arg, 'team', 'api', 'rpc');\n};\n\n/**\n * Lists members of a group. Permission : Team Information.\n * @function DropboxTeam#teamGroupsMembersList\n * @arg {TeamGroupsMembersListArg} arg - The request parameters.\n * @returns {Promise.<TeamGroupsMembersListResult, Error.<TeamGroupSelectorError>>}\n */\nroutes.teamGroupsMembersList = function (arg) {\n  return this.request('team/groups/members/list', arg, 'team', 'api', 'rpc');\n};\n\n/**\n * Once a cursor has been retrieved from groups/members/list, use this to\n * paginate through all members of the group. Permission : Team information.\n * @function DropboxTeam#teamGroupsMembersListContinue\n * @arg {TeamGroupsMembersListContinueArg} arg - The request parameters.\n * @returns {Promise.<TeamGroupsMembersListResult, Error.<TeamGroupsMembersListContinueError>>}\n */\nroutes.teamGroupsMembersListContinue = function (arg) {\n  return this.request('team/groups/members/list/continue', arg, 'team', 'api', 'rpc');\n};\n\n/**\n * Removes members from a group. The members are removed immediately. However\n * the revoking of group-owned resources may take additional time. Use the\n * groups/job_status/get to determine whether this process has completed. This\n * method permits removing the only owner of a group, even in cases where this\n * is not possible via the web client. Permission : Team member management.\n * @function DropboxTeam#teamGroupsMembersRemove\n * @arg {TeamGroupMembersRemoveArg} arg - The request parameters.\n * @returns {Promise.<TeamGroupMembersChangeResult, Error.<TeamGroupMembersRemoveError>>}\n */\nroutes.teamGroupsMembersRemove = function (arg) {\n  return this.request('team/groups/members/remove', arg, 'team', 'api', 'rpc');\n};\n\n/**\n * Sets a member's access type in a group. Permission : Team member management.\n * @function DropboxTeam#teamGroupsMembersSetAccessType\n * @arg {TeamGroupMembersSetAccessTypeArg} arg - The request parameters.\n * @returns {Promise.<Object, Error.<TeamGroupMemberSetAccessTypeError>>}\n */\nroutes.teamGroupsMembersSetAccessType = function (arg) {\n  return this.request('team/groups/members/set_access_type', arg, 'team', 'api', 'rpc');\n};\n\n/**\n * Updates a group's name and/or external ID. Permission : Team member\n * management.\n * @function DropboxTeam#teamGroupsUpdate\n * @arg {TeamGroupUpdateArgs} arg - The request parameters.\n * @returns {Promise.<TeamGroupFullInfo, Error.<TeamGroupUpdateError>>}\n */\nroutes.teamGroupsUpdate = function (arg) {\n  return this.request('team/groups/update', arg, 'team', 'api', 'rpc');\n};\n\n/**\n * List all linked applications of the team member. Note, this endpoint does not\n * list any team-linked applications.\n * @function DropboxTeam#teamLinkedAppsListMemberLinkedApps\n * @arg {TeamListMemberAppsArg} arg - The request parameters.\n * @returns {Promise.<TeamListMemberAppsResult, Error.<TeamListMemberAppsError>>}\n */\nroutes.teamLinkedAppsListMemberLinkedApps = function (arg) {\n  return this.request('team/linked_apps/list_member_linked_apps', arg, 'team', 'api', 'rpc');\n};\n\n/**\n * List all applications linked to the team members' accounts. Note, this\n * endpoint does not list any team-linked applications.\n * @function DropboxTeam#teamLinkedAppsListMembersLinkedApps\n * @arg {TeamListMembersAppsArg} arg - The request parameters.\n * @returns {Promise.<TeamListMembersAppsResult, Error.<TeamListMembersAppsError>>}\n */\nroutes.teamLinkedAppsListMembersLinkedApps = function (arg) {\n  return this.request('team/linked_apps/list_members_linked_apps', arg, 'team', 'api', 'rpc');\n};\n\n/**\n * List all applications linked to the team members' accounts. Note, this\n * endpoint doesn't list any team-linked applications.\n * @function DropboxTeam#teamLinkedAppsListTeamLinkedApps\n * @deprecated\n * @arg {TeamListTeamAppsArg} arg - The request parameters.\n * @returns {Promise.<TeamListTeamAppsResult, Error.<TeamListTeamAppsError>>}\n */\nroutes.teamLinkedAppsListTeamLinkedApps = function (arg) {\n  return this.request('team/linked_apps/list_team_linked_apps', arg, 'team', 'api', 'rpc');\n};\n\n/**\n * Revoke a linked application of the team member\n * @function DropboxTeam#teamLinkedAppsRevokeLinkedApp\n * @arg {TeamRevokeLinkedApiAppArg} arg - The request parameters.\n * @returns {Promise.<void, Error.<TeamRevokeLinkedAppError>>}\n */\nroutes.teamLinkedAppsRevokeLinkedApp = function (arg) {\n  return this.request('team/linked_apps/revoke_linked_app', arg, 'team', 'api', 'rpc');\n};\n\n/**\n * Revoke a list of linked applications of the team members\n * @function DropboxTeam#teamLinkedAppsRevokeLinkedAppBatch\n * @arg {TeamRevokeLinkedApiAppBatchArg} arg - The request parameters.\n * @returns {Promise.<TeamRevokeLinkedAppBatchResult, Error.<TeamRevokeLinkedAppBatchError>>}\n */\nroutes.teamLinkedAppsRevokeLinkedAppBatch = function (arg) {\n  return this.request('team/linked_apps/revoke_linked_app_batch', arg, 'team', 'api', 'rpc');\n};\n\n/**\n * Adds members to a team. Permission : Team member management A maximum of 20\n * members can be specified in a single call. If no Dropbox account exists with\n * the email address specified, a new Dropbox account will be created with the\n * given email address, and that account will be invited to the team. If a\n * personal Dropbox account exists with the email address specified in the call,\n * this call will create a placeholder Dropbox account for the user on the team\n * and send an email inviting the user to migrate their existing personal\n * account onto the team. Team member management apps are required to set an\n * initial given_name and surname for a user to use in the team invitation and\n * for 'Perform as team member' actions taken on the user before they become\n * 'active'.\n * @function DropboxTeam#teamMembersAdd\n * @arg {TeamMembersAddArg} arg - The request parameters.\n * @returns {Promise.<TeamMembersAddLaunch, Error.<void>>}\n */\nroutes.teamMembersAdd = function (arg) {\n  return this.request('team/members/add', arg, 'team', 'api', 'rpc');\n};\n\n/**\n * Once an async_job_id is returned from members/add , use this to poll the\n * status of the asynchronous request. Permission : Team member management\n * @function DropboxTeam#teamMembersAddJobStatusGet\n * @arg {AsyncPollArg} arg - The request parameters.\n * @returns {Promise.<TeamMembersAddJobStatus, Error.<AsyncPollError>>}\n */\nroutes.teamMembersAddJobStatusGet = function (arg) {\n  return this.request('team/members/add/job_status/get', arg, 'team', 'api', 'rpc');\n};\n\n/**\n * Returns information about multiple team members. Permission : Team\n * information This endpoint will return MembersGetInfoItem.id_not_found, for\n * IDs (or emails) that cannot be matched to a valid team member.\n * @function DropboxTeam#teamMembersGetInfo\n * @arg {TeamMembersGetInfoArgs} arg - The request parameters.\n * @returns {Promise.<Object, Error.<TeamMembersGetInfoError>>}\n */\nroutes.teamMembersGetInfo = function (arg) {\n  return this.request('team/members/get_info', arg, 'team', 'api', 'rpc');\n};\n\n/**\n * Lists members of a team. Permission : Team information\n * @function DropboxTeam#teamMembersList\n * @arg {TeamMembersListArg} arg - The request parameters.\n * @returns {Promise.<TeamMembersListResult, Error.<TeamMembersListError>>}\n */\nroutes.teamMembersList = function (arg) {\n  return this.request('team/members/list', arg, 'team', 'api', 'rpc');\n};\n\n/**\n * Once a cursor has been retrieved from members/list, use this to paginate\n * through all team members. Permission : Team information\n * @function DropboxTeam#teamMembersListContinue\n * @arg {TeamMembersListContinueArg} arg - The request parameters.\n * @returns {Promise.<TeamMembersListResult, Error.<TeamMembersListContinueError>>}\n */\nroutes.teamMembersListContinue = function (arg) {\n  return this.request('team/members/list/continue', arg, 'team', 'api', 'rpc');\n};\n\n/**\n * Recover a deleted member. Permission : Team member management Exactly one of\n * team_member_id, email, or external_id must be provided to identify the user\n * account.\n * @function DropboxTeam#teamMembersRecover\n * @arg {TeamMembersRecoverArg} arg - The request parameters.\n * @returns {Promise.<void, Error.<TeamMembersRecoverError>>}\n */\nroutes.teamMembersRecover = function (arg) {\n  return this.request('team/members/recover', arg, 'team', 'api', 'rpc');\n};\n\n/**\n * Removes a member from a team. Permission : Team member management Exactly one\n * of team_member_id, email, or external_id must be provided to identify the\n * user account. Accounts can be recovered via members/recover for a 7 day\n * period or until the account has been permanently deleted or transferred to\n * another account (whichever comes first). Calling members/add while a user is\n * still recoverable on your team will return with\n * MemberAddResult.user_already_on_team. This endpoint may initiate an\n * asynchronous job. To obtain the final result of the job, the client should\n * periodically poll members/remove/job_status/get.\n * @function DropboxTeam#teamMembersRemove\n * @arg {TeamMembersRemoveArg} arg - The request parameters.\n * @returns {Promise.<AsyncLaunchEmptyResult, Error.<TeamMembersRemoveError>>}\n */\nroutes.teamMembersRemove = function (arg) {\n  return this.request('team/members/remove', arg, 'team', 'api', 'rpc');\n};\n\n/**\n * Once an async_job_id is returned from members/remove , use this to poll the\n * status of the asynchronous request. Permission : Team member management\n * @function DropboxTeam#teamMembersRemoveJobStatusGet\n * @arg {AsyncPollArg} arg - The request parameters.\n * @returns {Promise.<AsyncPollEmptyResult, Error.<AsyncPollError>>}\n */\nroutes.teamMembersRemoveJobStatusGet = function (arg) {\n  return this.request('team/members/remove/job_status/get', arg, 'team', 'api', 'rpc');\n};\n\n/**\n * Sends welcome email to pending team member. Permission : Team member\n * management Exactly one of team_member_id, email, or external_id must be\n * provided to identify the user account. No-op if team member is not pending.\n * @function DropboxTeam#teamMembersSendWelcomeEmail\n * @arg {TeamUserSelectorArg} arg - The request parameters.\n * @returns {Promise.<void, Error.<TeamMembersSendWelcomeError>>}\n */\nroutes.teamMembersSendWelcomeEmail = function (arg) {\n  return this.request('team/members/send_welcome_email', arg, 'team', 'api', 'rpc');\n};\n\n/**\n * Updates a team member's permissions. Permission : Team member management\n * @function DropboxTeam#teamMembersSetAdminPermissions\n * @arg {TeamMembersSetPermissionsArg} arg - The request parameters.\n * @returns {Promise.<TeamMembersSetPermissionsResult, Error.<TeamMembersSetPermissionsError>>}\n */\nroutes.teamMembersSetAdminPermissions = function (arg) {\n  return this.request('team/members/set_admin_permissions', arg, 'team', 'api', 'rpc');\n};\n\n/**\n * Updates a team member's profile. Permission : Team member management\n * @function DropboxTeam#teamMembersSetProfile\n * @arg {TeamMembersSetProfileArg} arg - The request parameters.\n * @returns {Promise.<TeamTeamMemberInfo, Error.<TeamMembersSetProfileError>>}\n */\nroutes.teamMembersSetProfile = function (arg) {\n  return this.request('team/members/set_profile', arg, 'team', 'api', 'rpc');\n};\n\n/**\n * Suspend a member from a team. Permission : Team member management Exactly one\n * of team_member_id, email, or external_id must be provided to identify the\n * user account.\n * @function DropboxTeam#teamMembersSuspend\n * @arg {TeamMembersDeactivateArg} arg - The request parameters.\n * @returns {Promise.<void, Error.<TeamMembersSuspendError>>}\n */\nroutes.teamMembersSuspend = function (arg) {\n  return this.request('team/members/suspend', arg, 'team', 'api', 'rpc');\n};\n\n/**\n * Unsuspend a member from a team. Permission : Team member management Exactly\n * one of team_member_id, email, or external_id must be provided to identify the\n * user account.\n * @function DropboxTeam#teamMembersUnsuspend\n * @arg {TeamMembersUnsuspendArg} arg - The request parameters.\n * @returns {Promise.<void, Error.<TeamMembersUnsuspendError>>}\n */\nroutes.teamMembersUnsuspend = function (arg) {\n  return this.request('team/members/unsuspend', arg, 'team', 'api', 'rpc');\n};\n\n/**\n * Add a property template. See route files/properties/add to add properties to\n * a file.\n * @function DropboxTeam#teamPropertiesTemplateAdd\n * @arg {TeamAddPropertyTemplateArg} arg - The request parameters.\n * @returns {Promise.<TeamAddPropertyTemplateResult, Error.<PropertiesModifyPropertyTemplateError>>}\n */\nroutes.teamPropertiesTemplateAdd = function (arg) {\n  return this.request('team/properties/template/add', arg, 'team', 'api', 'rpc');\n};\n\n/**\n * Get the schema for a specified template.\n * @function DropboxTeam#teamPropertiesTemplateGet\n * @arg {PropertiesGetPropertyTemplateArg} arg - The request parameters.\n * @returns {Promise.<PropertiesGetPropertyTemplateResult, Error.<PropertiesPropertyTemplateError>>}\n */\nroutes.teamPropertiesTemplateGet = function (arg) {\n  return this.request('team/properties/template/get', arg, 'team', 'api', 'rpc');\n};\n\n/**\n * Get the property template identifiers for a team. To get the schema of each\n * template use properties/template/get.\n * @function DropboxTeam#teamPropertiesTemplateList\n * @arg {void} arg - The request parameters.\n * @returns {Promise.<PropertiesListPropertyTemplateIds, Error.<PropertiesPropertyTemplateError>>}\n */\nroutes.teamPropertiesTemplateList = function (arg) {\n  return this.request('team/properties/template/list', arg, 'team', 'api', 'rpc');\n};\n\n/**\n * Update a property template. This route can update the template name, the\n * template description and add optional properties to templates.\n * @function DropboxTeam#teamPropertiesTemplateUpdate\n * @arg {TeamUpdatePropertyTemplateArg} arg - The request parameters.\n * @returns {Promise.<TeamUpdatePropertyTemplateResult, Error.<PropertiesModifyPropertyTemplateError>>}\n */\nroutes.teamPropertiesTemplateUpdate = function (arg) {\n  return this.request('team/properties/template/update', arg, 'team', 'api', 'rpc');\n};\n\n/**\n * Retrieves reporting data about a team's user activity.\n * @function DropboxTeam#teamReportsGetActivity\n * @arg {TeamDateRange} arg - The request parameters.\n * @returns {Promise.<TeamGetActivityReport, Error.<TeamDateRangeError>>}\n */\nroutes.teamReportsGetActivity = function (arg) {\n  return this.request('team/reports/get_activity', arg, 'team', 'api', 'rpc');\n};\n\n/**\n * Retrieves reporting data about a team's linked devices.\n * @function DropboxTeam#teamReportsGetDevices\n * @arg {TeamDateRange} arg - The request parameters.\n * @returns {Promise.<TeamGetDevicesReport, Error.<TeamDateRangeError>>}\n */\nroutes.teamReportsGetDevices = function (arg) {\n  return this.request('team/reports/get_devices', arg, 'team', 'api', 'rpc');\n};\n\n/**\n * Retrieves reporting data about a team's membership.\n * @function DropboxTeam#teamReportsGetMembership\n * @arg {TeamDateRange} arg - The request parameters.\n * @returns {Promise.<TeamGetMembershipReport, Error.<TeamDateRangeError>>}\n */\nroutes.teamReportsGetMembership = function (arg) {\n  return this.request('team/reports/get_membership', arg, 'team', 'api', 'rpc');\n};\n\n/**\n * Retrieves reporting data about a team's storage usage.\n * @function DropboxTeam#teamReportsGetStorage\n * @arg {TeamDateRange} arg - The request parameters.\n * @returns {Promise.<TeamGetStorageReport, Error.<TeamDateRangeError>>}\n */\nroutes.teamReportsGetStorage = function (arg) {\n  return this.request('team/reports/get_storage', arg, 'team', 'api', 'rpc');\n};\n\n/**\n * Sets an archived team folder's status to active. Permission : Team member\n * file access.\n * @function DropboxTeam#teamTeamFolderActivate\n * @arg {TeamTeamFolderIdArg} arg - The request parameters.\n * @returns {Promise.<TeamTeamFolderMetadata, Error.<TeamTeamFolderActivateError>>}\n */\nroutes.teamTeamFolderActivate = function (arg) {\n  return this.request('team/team_folder/activate', arg, 'team', 'api', 'rpc');\n};\n\n/**\n * Sets an active team folder's status to archived and removes all folder and\n * file members. Permission : Team member file access.\n * @function DropboxTeam#teamTeamFolderArchive\n * @arg {TeamTeamFolderArchiveArg} arg - The request parameters.\n * @returns {Promise.<TeamTeamFolderArchiveLaunch, Error.<TeamTeamFolderArchiveError>>}\n */\nroutes.teamTeamFolderArchive = function (arg) {\n  return this.request('team/team_folder/archive', arg, 'team', 'api', 'rpc');\n};\n\n/**\n * Returns the status of an asynchronous job for archiving a team folder.\n * Permission : Team member file access.\n * @function DropboxTeam#teamTeamFolderArchiveCheck\n * @arg {AsyncPollArg} arg - The request parameters.\n * @returns {Promise.<TeamTeamFolderArchiveJobStatus, Error.<AsyncPollError>>}\n */\nroutes.teamTeamFolderArchiveCheck = function (arg) {\n  return this.request('team/team_folder/archive/check', arg, 'team', 'api', 'rpc');\n};\n\n/**\n * Creates a new, active, team folder. Permission : Team member file access.\n * @function DropboxTeam#teamTeamFolderCreate\n * @arg {TeamTeamFolderCreateArg} arg - The request parameters.\n * @returns {Promise.<TeamTeamFolderMetadata, Error.<TeamTeamFolderCreateError>>}\n */\nroutes.teamTeamFolderCreate = function (arg) {\n  return this.request('team/team_folder/create', arg, 'team', 'api', 'rpc');\n};\n\n/**\n * Retrieves metadata for team folders. Permission : Team member file access.\n * @function DropboxTeam#teamTeamFolderGetInfo\n * @arg {TeamTeamFolderIdListArg} arg - The request parameters.\n * @returns {Promise.<Array.<TeamTeamFolderGetInfoItem>, Error.<void>>}\n */\nroutes.teamTeamFolderGetInfo = function (arg) {\n  return this.request('team/team_folder/get_info', arg, 'team', 'api', 'rpc');\n};\n\n/**\n * Lists all team folders. Permission : Team member file access.\n * @function DropboxTeam#teamTeamFolderList\n * @arg {TeamTeamFolderListArg} arg - The request parameters.\n * @returns {Promise.<TeamTeamFolderListResult, Error.<TeamTeamFolderListError>>}\n */\nroutes.teamTeamFolderList = function (arg) {\n  return this.request('team/team_folder/list', arg, 'team', 'api', 'rpc');\n};\n\n/**\n * Permanently deletes an archived team folder. Permission : Team member file\n * access.\n * @function DropboxTeam#teamTeamFolderPermanentlyDelete\n * @arg {TeamTeamFolderIdArg} arg - The request parameters.\n * @returns {Promise.<void, Error.<TeamTeamFolderPermanentlyDeleteError>>}\n */\nroutes.teamTeamFolderPermanentlyDelete = function (arg) {\n  return this.request('team/team_folder/permanently_delete', arg, 'team', 'api', 'rpc');\n};\n\n/**\n * Changes an active team folder's name. Permission : Team member file access.\n * @function DropboxTeam#teamTeamFolderRename\n * @arg {TeamTeamFolderRenameArg} arg - The request parameters.\n * @returns {Promise.<TeamTeamFolderMetadata, Error.<TeamTeamFolderRenameError>>}\n */\nroutes.teamTeamFolderRename = function (arg) {\n  return this.request('team/team_folder/rename', arg, 'team', 'api', 'rpc');\n};\n\nmodule.exports = routes;\n","/home/travis/build/npmtest/node-npmtest-dropbox/node_modules/dropbox/src/rpc-request.js":"var request = require('superagent');\nvar Promise = require('es6-promise').Promise;\nvar getBaseURL = require('./get-base-url');\n\n// This doesn't match what was spec'd in paper doc yet\nvar buildCustomError = function (error, response) {\n  return {\n    status: error.status,\n    error: (response ? response.text : null) || error.toString(),\n    response: response\n  };\n};\n\nvar rpcRequest = function (path, body, auth, host, accessToken, selectUser) {\n  var promiseFunction = function (resolve, reject) {\n    var apiRequest;\n\n    function success(data) {\n      if (resolve) {\n        resolve(data);\n      }\n    }\n\n    function failure(error) {\n      if (reject) {\n        reject(error);\n      }\n    }\n\n    function responseHandler(error, response) {\n      if (error) {\n        failure(buildCustomError(error, response));\n      } else {\n        success(response.body);\n      }\n    }\n\n    // The API expects null to be passed for endpoints that dont accept any\n    // parameters\n    if (!body) {\n      body = null;\n    }\n\n    apiRequest = request.post(getBaseURL(host) + path)\n      .type('application/json');\n\n    switch (auth) {\n      case 'team':\n      case 'user':\n        apiRequest.set('Authorization', 'Bearer ' + accessToken);\n        break;\n      case 'noauth':\n        break;\n      default:\n        throw new Error('Unhandled auth type: ' + auth);\n    }\n\n    if (selectUser) {\n      apiRequest = apiRequest.set('Dropbox-API-Select-User', selectUser);\n    }\n\n    apiRequest.send(body)\n      .end(responseHandler);\n  };\n\n  return new Promise(promiseFunction);\n};\n\nmodule.exports = rpcRequest;\n","/home/travis/build/npmtest/node-npmtest-dropbox/node_modules/dropbox/src/types.js":"// Auto-generated by Stone, do not modify.\n/**\n * An Error object returned from a route.\n * @typedef {Object} Error\n * @property {string} error_summary - Text summary of the error.\n * @property {T} error - The error object.\n * @property {UserMessage} user_message - User-friendly error message.\n * @template T\n */\n\n/**\n * User-friendly error message.\n * @typedef {Object} UserMessage\n * @property {string} text - The message.\n * @property {string} locale\n */\n\n /**\n  * @typedef {string} Timestamp\n  */\n\n/**\n * Result returned by methods that may either launch an asynchronous job or\n * complete synchronously. Upon synchronous completion of the job, no additional\n * information is returned.\n * @typedef {Object} AsyncLaunchEmptyResult\n * @property {string} [async_job_id] - Available if .tag is async_job_id. This\n * response indicates that the processing is asynchronous. The string is an id\n * that can be used to obtain the status of the asynchronous job.\n * @property {('async_job_id'|'complete')} .tag - Tag identifying the union variant.\n */\n\n/**\n * Result returned by methods that launch an asynchronous job. A method who may\n * either launch an asynchronous job, or complete the request synchronously, can\n * use this union by extending it, and adding a 'complete' field with the type\n * of the synchronous response. See LaunchEmptyResult for an example.\n * @typedef {Object} AsyncLaunchResultBase\n * @property {string} [async_job_id] - Available if .tag is async_job_id. This\n * response indicates that the processing is asynchronous. The string is an id\n * that can be used to obtain the status of the asynchronous job.\n * @property {'async_job_id'} .tag - Tag identifying the union variant.\n */\n\n/**\n * Arguments for methods that poll the status of an asynchronous job.\n * @typedef {Object} AsyncPollArg\n * @property {string} async_job_id - Id of the asynchronous job. This is the\n * value of a response returned from the method that launched the job.\n */\n\n/**\n * Result returned by methods that poll for the status of an asynchronous job.\n * Upon completion of the job, no additional information is returned.\n * @typedef {Object} AsyncPollEmptyResult\n * @property {('in_progress'|'complete')} .tag - Tag identifying the union variant.\n */\n\n/**\n * Error returned by methods for polling the status of asynchronous job.\n * @typedef {Object} AsyncPollError\n * @property {('invalid_async_job_id'|'internal_error'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * Result returned by methods that poll for the status of an asynchronous job.\n * Unions that extend this union should add a 'complete' field with a type of\n * the information returned upon job completion. See PollEmptyResult for an\n * example.\n * @typedef {Object} AsyncPollResultBase\n * @property {'in_progress'} .tag - Tag identifying the union variant.\n */\n\n/**\n * Error occurred because the account doesn't have permission to access the\n * resource.\n * @typedef {Object} AuthAccessError\n * @property {AuthInvalidAccountTypeError} [invalid_account_type] - Available if\n * .tag is invalid_account_type. Current account type cannot access the\n * resource.\n * @property {AuthPaperAccessError} [paper_access_denied] - Available if .tag is\n * paper_access_denied. Current account cannot access Paper.\n * @property {('invalid_account_type'|'paper_access_denied'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * Errors occurred during authentication.\n * @typedef {Object} AuthAuthError\n * @property {('invalid_access_token'|'invalid_select_user'|'invalid_select_admin'|'user_suspended'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} AuthInvalidAccountTypeError\n * @property {('endpoint'|'feature'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} AuthPaperAccessError\n * @property {('paper_disabled'|'not_paper_user'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * Error occurred because the app is being rate limited.\n * @typedef {Object} AuthRateLimitError\n * @property {AuthRateLimitReason} reason - The reason why the app is being rate\n * limited.\n * @property {number} retry_after - The number of seconds that the app should\n * wait before making another request.\n */\n\n/**\n * @typedef {Object} AuthRateLimitReason\n * @property {('too_many_requests'|'too_many_write_operations'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} AuthTokenFromOAuth1Arg\n * @property {string} oauth1_token - The supplied OAuth 1.0 access token.\n * @property {string} oauth1_token_secret - The token secret associated with the\n * supplied access token.\n */\n\n/**\n * @typedef {Object} AuthTokenFromOAuth1Error\n * @property {('invalid_oauth1_token_info'|'app_id_mismatch'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} AuthTokenFromOAuth1Result\n * @property {string} oauth2_token - The OAuth 2.0 token generated from the\n * supplied OAuth 1.0 token.\n */\n\n/**\n * @typedef {Object} FilesAddPropertiesError\n * @property {string} [template_not_found] - Available if .tag is\n * template_not_found. Property template does not exist for given identifier.\n * @property {FilesLookupError} [path] - Available if .tag is path.\n * @property {('template_not_found'|'restricted_content'|'other'|'path'|'property_field_too_large'|'does_not_fit_template'|'property_group_already_exists')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} FilesAlphaGetMetadataArg\n * @property {string} path - The path of a file or folder on Dropbox.\n * @property {boolean} include_media_info - If true, FileMetadata.media_info is\n * set for photo and video.\n * @property {boolean} include_deleted - If true, DeletedMetadata will be\n * returned for deleted file or folder, otherwise LookupError.not_found will be\n * returned.\n * @property {boolean} include_has_explicit_shared_members - If true, the\n * results will include a flag for each file indicating whether or not  that\n * file has any explicit members.\n * @property {Array.<Object>} [include_property_templates] - If set to a valid\n * list of template IDs, FileMetadata.property_groups is set for files with\n * custom properties.\n */\n\n/**\n * @typedef {Object} FilesAlphaGetMetadataError\n * @property {FilesLookupError} [path] - Available if .tag is path.\n * @property {FilesLookUpPropertiesError} [properties_error] - Available if .tag\n * is properties_error.\n * @property {('path'|'properties_error')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} FilesCommitInfo\n * @property {Object} contents - The file contents to be uploaded.\n * @property {string} path - Path in the user's Dropbox to save the file.\n * @property {FilesWriteMode} mode - Selects what to do if the file already\n * exists.\n * @property {boolean} autorename - If there's a conflict, as determined by\n * mode, have the Dropbox server try to autorename the file to avoid conflict.\n * @property {Timestamp} [client_modified] - The value to store as the\n * client_modified timestamp. Dropbox automatically records the time at which\n * the file was written to the Dropbox servers. It can also record an additional\n * timestamp, provided by Dropbox desktop clients, mobile clients, and API apps\n * of when the file was actually created or modified.\n * @property {boolean} mute - Normally, users are made aware of any file\n * modifications in their Dropbox account via notifications in the client\n * software. If true, this tells the clients that this modification shouldn't\n * result in a user notification.\n */\n\n/**\n * @typedef {Object} FilesCommitInfoWithProperties\n * @property {Object} contents - The file contents to be uploaded.\n * @property {string} path - Path in the user's Dropbox to save the file.\n * @property {FilesWriteMode} mode - Selects what to do if the file already\n * exists.\n * @property {boolean} autorename - If there's a conflict, as determined by\n * mode, have the Dropbox server try to autorename the file to avoid conflict.\n * @property {Timestamp} [client_modified] - The value to store as the\n * client_modified timestamp. Dropbox automatically records the time at which\n * the file was written to the Dropbox servers. It can also record an additional\n * timestamp, provided by Dropbox desktop clients, mobile clients, and API apps\n * of when the file was actually created or modified.\n * @property {boolean} mute - Normally, users are made aware of any file\n * modifications in their Dropbox account via notifications in the client\n * software. If true, this tells the clients that this modification shouldn't\n * result in a user notification.\n * @property {Array.<PropertiesPropertyGroup>} [property_groups] - List of\n * custom properties to add to file.\n */\n\n/**\n * @typedef {Object} FilesCreateFolderArg\n * @property {string} path - Path in the user's Dropbox to create.\n * @property {boolean} autorename - If there's a conflict, have the Dropbox\n * server try to autorename the folder to avoid the conflict.\n */\n\n/**\n * @typedef {Object} FilesCreateFolderError\n * @property {FilesWriteError} [path] - Available if .tag is path.\n * @property {'path'} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} FilesDeleteArg\n * @property {string} path - Path in the user's Dropbox to delete.\n */\n\n/**\n * @typedef {Object} FilesDeleteBatchArg\n * @property {Array.<FilesDeleteArg>} entries\n */\n\n/**\n * @typedef {Object} FilesDeleteBatchError\n * @property {('too_many_write_operations'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} FilesDeleteBatchJobStatus\n * @property {FilesDeleteBatchResult} [complete] - Available if .tag is\n * complete. The batch delete has finished.\n * @property {FilesDeleteBatchError} [failed] - Available if .tag is failed. The\n * batch delete has failed.\n * @property {('in_progress'|'complete'|'failed'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * Result returned by delete_batch that may either launch an asynchronous job or\n * complete synchronously.\n * @typedef {Object} FilesDeleteBatchLaunch\n * @property {string} [async_job_id] - Available if .tag is async_job_id. This\n * response indicates that the processing is asynchronous. The string is an id\n * that can be used to obtain the status of the asynchronous job.\n * @property {FilesDeleteBatchResult} [complete] - Available if .tag is\n * complete.\n * @property {('async_job_id'|'complete'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} FilesDeleteBatchResult\n * @property {Array.<FilesDeleteBatchResultEntry>} entries\n */\n\n/**\n * @typedef {Object} FilesDeleteBatchResultEntry\n * @property {FilesDeleteResult} [success] - Available if .tag is success.\n * @property {FilesDeleteError} [failure] - Available if .tag is failure.\n * @property {('success'|'failure')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} FilesDeleteError\n * @property {FilesLookupError} [path_lookup] - Available if .tag is\n * path_lookup.\n * @property {FilesWriteError} [path_write] - Available if .tag is path_write.\n * @property {('path_lookup'|'path_write'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} FilesDeleteResult\n * @property {(FilesFileMetadata|FilesFolderMetadata|FilesDeletedMetadata)}\n * metadata\n */\n\n/**\n * Indicates that there used to be a file or folder at this path, but it no\n * longer exists.\n * @typedef {Object} FilesDeletedMetadata\n@property {'deleted'} [.tag] - Tag identifying this subtype variant. This field\nis only present when needed to discriminate between multiple possible subtypes.\n * @property {string} name - The last component of the path (including\n * extension). This never contains a slash.\n * @property {string} [path_lower] - The lowercased full path in the user's\n * Dropbox. This always starts with a slash. This field will be null if the file\n * or folder is not mounted.\n * @property {string} [path_display] - The cased path to be used for display\n * purposes only. In rare instances the casing will not correctly match the\n * user's filesystem, but this behavior will match the path provided in the Core\n * API v1, and at least the last path component will have the correct casing.\n * Changes to only the casing of paths won't be returned by\n * list_folder/continue. This field will be null if the file or folder is not\n * mounted.\n * @property {string} [parent_shared_folder_id] - Deprecated. Please use\n * FileSharingInfo.parent_shared_folder_id or\n * FolderSharingInfo.parent_shared_folder_id instead.\n */\n\n/**\n * Dimensions for a photo or video.\n * @typedef {Object} FilesDimensions\n * @property {number} height - Height of the photo/video.\n * @property {number} width - Width of the photo/video.\n */\n\n/**\n * @typedef {Object} FilesDownloadArg\n * @property {string} path - The path of the file to download.\n * @property {string} [rev] - Deprecated. Please specify revision in path\n * instead.\n */\n\n/**\n * @typedef {Object} FilesDownloadError\n * @property {FilesLookupError} [path] - Available if .tag is path.\n * @property {('path'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} FilesFileMetadata\n@property {'file'} [.tag] - Tag identifying this subtype variant. This field is\nonly present when needed to discriminate between multiple possible subtypes.\n * @property {string} name - The last component of the path (including\n * extension). This never contains a slash.\n * @property {string} id - A unique identifier for the file.\n * @property {Timestamp} client_modified - For files, this is the modification\n * time set by the desktop client when the file was added to Dropbox. Since this\n * time is not verified (the Dropbox server stores whatever the desktop client\n * sends up), this should only be used for display purposes (such as sorting)\n * and not, for example, to determine if a file has changed or not.\n * @property {Timestamp} server_modified - The last time the file was modified\n * on Dropbox.\n * @property {string} rev - A unique identifier for the current revision of a\n * file. This field is the same rev as elsewhere in the API and can be used to\n * detect changes and avoid conflicts.\n * @property {number} size - The file size in bytes.\n * @property {string} [path_lower] - The lowercased full path in the user's\n * Dropbox. This always starts with a slash. This field will be null if the file\n * or folder is not mounted.\n * @property {string} [path_display] - The cased path to be used for display\n * purposes only. In rare instances the casing will not correctly match the\n * user's filesystem, but this behavior will match the path provided in the Core\n * API v1, and at least the last path component will have the correct casing.\n * Changes to only the casing of paths won't be returned by\n * list_folder/continue. This field will be null if the file or folder is not\n * mounted.\n * @property {string} [parent_shared_folder_id] - Deprecated. Please use\n * FileSharingInfo.parent_shared_folder_id or\n * FolderSharingInfo.parent_shared_folder_id instead.\n * @property {FilesMediaInfo} [media_info] - Additional information if the file\n * is a photo or video.\n * @property {FilesFileSharingInfo} [sharing_info] - Set if this file is\n * contained in a shared folder.\n * @property {Array.<PropertiesPropertyGroup>} [property_groups] - Additional\n * information if the file has custom properties with the property template\n * specified.\n * @property {boolean} [has_explicit_shared_members] - This flag will only be\n * present if include_has_explicit_shared_members  is true in list_folder or\n * get_metadata. If this  flag is present, it will be true if this file has any\n * explicit shared  members. This is different from sharing_info in that this\n * could be true  in the case where a file has explicit members but is not\n * contained within  a shared folder.\n * @property {string} [content_hash] - A hash of the file content. This field\n * can be used to verify data integrity. For more information see our Content\n * hash /developers/reference/content-hash page.\n */\n\n/**\n * Sharing info for a file which is contained by a shared folder.\n * @typedef {Object} FilesFileSharingInfo\n * @property {boolean} read_only - True if the file or folder is inside a\n * read-only shared folder.\n * @property {string} parent_shared_folder_id - ID of shared folder that holds\n * this file.\n * @property {string} [modified_by] - The last user who modified the file. This\n * field will be null if the user's account has been deleted.\n */\n\n/**\n * @typedef {Object} FilesFolderMetadata\n@property {'folder'} [.tag] - Tag identifying this subtype variant. This field\nis only present when needed to discriminate between multiple possible subtypes.\n * @property {string} name - The last component of the path (including\n * extension). This never contains a slash.\n * @property {string} id - A unique identifier for the folder.\n * @property {string} [path_lower] - The lowercased full path in the user's\n * Dropbox. This always starts with a slash. This field will be null if the file\n * or folder is not mounted.\n * @property {string} [path_display] - The cased path to be used for display\n * purposes only. In rare instances the casing will not correctly match the\n * user's filesystem, but this behavior will match the path provided in the Core\n * API v1, and at least the last path component will have the correct casing.\n * Changes to only the casing of paths won't be returned by\n * list_folder/continue. This field will be null if the file or folder is not\n * mounted.\n * @property {string} [parent_shared_folder_id] - Deprecated. Please use\n * FileSharingInfo.parent_shared_folder_id or\n * FolderSharingInfo.parent_shared_folder_id instead.\n * @property {string} [shared_folder_id] - Deprecated. Please use sharing_info\n * instead.\n * @property {FilesFolderSharingInfo} [sharing_info] - Set if the folder is\n * contained in a shared folder or is a shared folder mount point.\n * @property {Array.<PropertiesPropertyGroup>} [property_groups] - Additional\n * information if the file has custom properties with the property template\n * specified.\n */\n\n/**\n * Sharing info for a folder which is contained in a shared folder or is a\n * shared folder mount point.\n * @typedef {Object} FilesFolderSharingInfo\n * @property {boolean} read_only - True if the file or folder is inside a\n * read-only shared folder.\n * @property {string} [parent_shared_folder_id] - Set if the folder is contained\n * by a shared folder.\n * @property {string} [shared_folder_id] - If this folder is a shared folder\n * mount point, the ID of the shared folder mounted at this location.\n * @property {boolean} traverse_only - Specifies that the folder can only be\n * traversed and the user can only see a limited subset of the contents of this\n * folder because they don't have read access to this folder. They do, however,\n * have access to some sub folder.\n * @property {boolean} no_access - Specifies that the folder cannot be accessed\n * by the user.\n */\n\n/**\n * @typedef {Object} FilesGetCopyReferenceArg\n * @property {string} path - The path to the file or folder you want to get a\n * copy reference to.\n */\n\n/**\n * @typedef {Object} FilesGetCopyReferenceError\n * @property {FilesLookupError} [path] - Available if .tag is path.\n * @property {('path'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} FilesGetCopyReferenceResult\n * @property {(FilesFileMetadata|FilesFolderMetadata|FilesDeletedMetadata)}\n * metadata - Metadata of the file or folder.\n * @property {string} copy_reference - A copy reference to the file or folder.\n * @property {Timestamp} expires - The expiration date of the copy reference.\n * This value is currently set to be far enough in the future so that expiration\n * is effectively not an issue.\n */\n\n/**\n * @typedef {Object} FilesGetMetadataArg\n * @property {string} path - The path of a file or folder on Dropbox.\n * @property {boolean} include_media_info - If true, FileMetadata.media_info is\n * set for photo and video.\n * @property {boolean} include_deleted - If true, DeletedMetadata will be\n * returned for deleted file or folder, otherwise LookupError.not_found will be\n * returned.\n * @property {boolean} include_has_explicit_shared_members - If true, the\n * results will include a flag for each file indicating whether or not  that\n * file has any explicit members.\n */\n\n/**\n * @typedef {Object} FilesGetMetadataError\n * @property {FilesLookupError} [path] - Available if .tag is path.\n * @property {'path'} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} FilesGetTemporaryLinkArg\n * @property {string} path - The path to the file you want a temporary link to.\n */\n\n/**\n * @typedef {Object} FilesGetTemporaryLinkError\n * @property {FilesLookupError} [path] - Available if .tag is path.\n * @property {('path'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} FilesGetTemporaryLinkResult\n * @property {FilesFileMetadata} metadata - Metadata of the file.\n * @property {string} link - The temporary link which can be used to stream\n * content the file.\n */\n\n/**\n * GPS coordinates for a photo or video.\n * @typedef {Object} FilesGpsCoordinates\n * @property {number} latitude - Latitude of the GPS coordinates.\n * @property {number} longitude - Longitude of the GPS coordinates.\n */\n\n/**\n * @typedef {Object} FilesInvalidPropertyGroupError\n * @property {string} [template_not_found] - Available if .tag is\n * template_not_found. Property template does not exist for given identifier.\n * @property {FilesLookupError} [path] - Available if .tag is path.\n * @property {('template_not_found'|'restricted_content'|'other'|'path'|'property_field_too_large'|'does_not_fit_template')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} FilesListFolderArg\n * @property {string} path - The path to the folder you want to see the contents\n * of.\n * @property {boolean} recursive - If true, the list folder operation will be\n * applied recursively to all subfolders and the response will contain contents\n * of all subfolders.\n * @property {boolean} include_media_info - If true, FileMetadata.media_info is\n * set for photo and video.\n * @property {boolean} include_deleted - If true, the results will include\n * entries for files and folders that used to exist but were deleted.\n * @property {boolean} include_has_explicit_shared_members - If true, the\n * results will include a flag for each file indicating whether or not  that\n * file has any explicit members.\n */\n\n/**\n * @typedef {Object} FilesListFolderContinueArg\n * @property {string} cursor - The cursor returned by your last call to\n * list_folder or list_folder/continue.\n */\n\n/**\n * @typedef {Object} FilesListFolderContinueError\n * @property {FilesLookupError} [path] - Available if .tag is path.\n * @property {('path'|'reset'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} FilesListFolderError\n * @property {FilesLookupError} [path] - Available if .tag is path.\n * @property {('path'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} FilesListFolderGetLatestCursorResult\n * @property {string} cursor - Pass the cursor into list_folder/continue to see\n * what's changed in the folder since your previous query.\n */\n\n/**\n * @typedef {Object} FilesListFolderLongpollArg\n * @property {string} cursor - A cursor as returned by list_folder or\n * list_folder/continue. Cursors retrieved by setting\n * ListFolderArg.include_media_info to true are not supported.\n * @property {number} timeout - A timeout in seconds. The request will block for\n * at most this length of time, plus up to 90 seconds of random jitter added to\n * avoid the thundering herd problem. Care should be taken when using this\n * parameter, as some network infrastructure does not support long timeouts.\n */\n\n/**\n * @typedef {Object} FilesListFolderLongpollError\n * @property {('reset'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} FilesListFolderLongpollResult\n * @property {boolean} changes - Indicates whether new changes are available. If\n * true, call list_folder/continue to retrieve the changes.\n * @property {number} [backoff] - If present, backoff for at least this many\n * seconds before calling list_folder/longpoll again.\n */\n\n/**\n * @typedef {Object} FilesListFolderResult\n * @property\n * {Array.<(FilesFileMetadata|FilesFolderMetadata|FilesDeletedMetadata)>}\n * entries - The files and (direct) subfolders in the folder.\n * @property {string} cursor - Pass the cursor into list_folder/continue to see\n * what's changed in the folder since your previous query.\n * @property {boolean} has_more - If true, then there are more entries\n * available. Pass the cursor to list_folder/continue to retrieve the rest.\n */\n\n/**\n * @typedef {Object} FilesListRevisionsArg\n * @property {string} path - The path to the file you want to see the revisions\n * of.\n * @property {number} limit - The maximum number of revision entries returned.\n */\n\n/**\n * @typedef {Object} FilesListRevisionsError\n * @property {FilesLookupError} [path] - Available if .tag is path.\n * @property {('path'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} FilesListRevisionsResult\n * @property {boolean} is_deleted - If the file is deleted.\n * @property {Array.<FilesFileMetadata>} entries - The revisions for the file.\n * Only non-delete revisions will show up here.\n */\n\n/**\n * @typedef {Object} FilesLookUpPropertiesError\n * @property {'property_group_not_found'} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} FilesLookupError\n * @property {string} [malformed_path] - Available if .tag is malformed_path.\n * @property {FilesPathRootError} [invalid_path_root] - Available if .tag is\n * invalid_path_root. The path root parameter provided is invalid.\n * @property {('malformed_path'|'not_found'|'not_file'|'not_folder'|'restricted_content'|'invalid_path_root'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} FilesMediaInfo\n * @property {(FilesPhotoMetadata|FilesVideoMetadata)} [metadata] - Available if\n * .tag is metadata. The metadata for the photo/video.\n * @property {('pending'|'metadata')} .tag - Tag identifying the union variant.\n */\n\n/**\n * Metadata for a photo or video.\n * @typedef {Object} FilesMediaMetadata\n@property {(\"photo\"|\"video\")} .tag - Tag identifying the subtype variant.\n * @property {FilesDimensions} [dimensions] - Dimension of the photo/video.\n * @property {FilesGpsCoordinates} [location] - The GPS coordinate of the\n * photo/video.\n * @property {Timestamp} [time_taken] - The timestamp when the photo/video is\n * taken.\n */\n\n/**\n * Metadata for a file or folder.\n * @typedef {Object} FilesMetadata\n@property {(\"file\"|\"folder\"|\"deleted\")} .tag - Tag identifying the subtype\nvariant.\n * @property {string} name - The last component of the path (including\n * extension). This never contains a slash.\n * @property {string} [path_lower] - The lowercased full path in the user's\n * Dropbox. This always starts with a slash. This field will be null if the file\n * or folder is not mounted.\n * @property {string} [path_display] - The cased path to be used for display\n * purposes only. In rare instances the casing will not correctly match the\n * user's filesystem, but this behavior will match the path provided in the Core\n * API v1, and at least the last path component will have the correct casing.\n * Changes to only the casing of paths won't be returned by\n * list_folder/continue. This field will be null if the file or folder is not\n * mounted.\n * @property {string} [parent_shared_folder_id] - Deprecated. Please use\n * FileSharingInfo.parent_shared_folder_id or\n * FolderSharingInfo.parent_shared_folder_id instead.\n */\n\n/**\n * @typedef {Object} FilesPathRootError\n * @property {string} [path_root] - The user's latest path root value. None if\n * the user no longer has a path root.\n */\n\n/**\n * Metadata for a photo.\n * @typedef {Object} FilesPhotoMetadata\n@property {'photo'} [.tag] - Tag identifying this subtype variant. This field is\nonly present when needed to discriminate between multiple possible subtypes.\n * @property {FilesDimensions} [dimensions] - Dimension of the photo/video.\n * @property {FilesGpsCoordinates} [location] - The GPS coordinate of the\n * photo/video.\n * @property {Timestamp} [time_taken] - The timestamp when the photo/video is\n * taken.\n */\n\n/**\n * @typedef {Object} FilesPreviewArg\n * @property {string} path - The path of the file to preview.\n * @property {string} [rev] - Deprecated. Please specify revision in path\n * instead.\n */\n\n/**\n * @typedef {Object} FilesPreviewError\n * @property {FilesLookupError} [path] - Available if .tag is path. An error\n * occurs when downloading metadata for the file.\n * @property {('path'|'in_progress'|'unsupported_extension'|'unsupported_content')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} FilesPropertiesError\n * @property {string} [template_not_found] - Available if .tag is\n * template_not_found. Property template does not exist for given identifier.\n * @property {FilesLookupError} [path] - Available if .tag is path.\n * @property {('template_not_found'|'restricted_content'|'other'|'path')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} FilesPropertyGroupUpdate\n * @property {string} template_id - A unique identifier for a property template.\n * @property {Array.<PropertiesPropertyField>} [add_or_update_fields] - List of\n * property fields to update if the field already exists. If the field doesn't\n * exist, add the field to the property group.\n * @property {Array.<string>} [remove_fields] - List of property field names to\n * remove from property group if the field exists.\n */\n\n/**\n * @typedef {Object} FilesPropertyGroupWithPath\n * @property {string} path - A unique identifier for the file.\n * @property {Array.<PropertiesPropertyGroup>} property_groups - Filled custom\n * property templates associated with a file.\n */\n\n/**\n * @typedef {Object} FilesRelocationArg\n * @property {string} from_path - Path in the user's Dropbox to be copied or\n * moved.\n * @property {string} to_path - Path in the user's Dropbox that is the\n * destination.\n * @property {boolean} allow_shared_folder - If true, copy will copy contents in\n * shared folder, otherwise RelocationError.cant_copy_shared_folder will be\n * returned if from_path contains shared folder. This field is always true for\n * move.\n * @property {boolean} autorename - If there's a conflict, have the Dropbox\n * server try to autorename the file to avoid the conflict.\n */\n\n/**\n * @typedef {Object} FilesRelocationBatchArg\n * @property {Array.<FilesRelocationPath>} entries - List of entries to be moved\n * or copied. Each entry is RelocationPath.\n * @property {boolean} allow_shared_folder - If true, copy_batch will copy\n * contents in shared folder, otherwise RelocationError.cant_copy_shared_folder\n * will be returned if RelocationPath.from_path contains shared folder.  This\n * field is always true for move_batch.\n * @property {boolean} autorename - If there's a conflict with any file, have\n * the Dropbox server try to autorename that file to avoid the conflict.\n */\n\n/**\n * @typedef {Object} FilesRelocationBatchError\n * @property {FilesLookupError} [from_lookup] - Available if .tag is\n * from_lookup.\n * @property {FilesWriteError} [from_write] - Available if .tag is from_write.\n * @property {FilesWriteError} [to] - Available if .tag is to.\n * @property {('from_lookup'|'from_write'|'to'|'cant_copy_shared_folder'|'cant_nest_shared_folder'|'cant_move_folder_into_itself'|'too_many_files'|'duplicated_or_nested_paths'|'other'|'too_many_write_operations')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} FilesRelocationBatchJobStatus\n * @property {FilesRelocationBatchResult} [complete] - Available if .tag is\n * complete. The copy or move batch job has finished.\n * @property {FilesRelocationBatchError} [failed] - Available if .tag is failed.\n * The copy or move batch job has failed with exception.\n * @property {('in_progress'|'complete'|'failed')} .tag - Tag identifying the union variant.\n */\n\n/**\n * Result returned by copy_batch or move_batch that may either launch an\n * asynchronous job or complete synchronously.\n * @typedef {Object} FilesRelocationBatchLaunch\n * @property {string} [async_job_id] - Available if .tag is async_job_id. This\n * response indicates that the processing is asynchronous. The string is an id\n * that can be used to obtain the status of the asynchronous job.\n * @property {FilesRelocationBatchResult} [complete] - Available if .tag is\n * complete.\n * @property {('async_job_id'|'complete'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} FilesRelocationBatchResult\n * @property {Array.<FilesRelocationResult>} entries\n */\n\n/**\n * @typedef {Object} FilesRelocationError\n * @property {FilesLookupError} [from_lookup] - Available if .tag is\n * from_lookup.\n * @property {FilesWriteError} [from_write] - Available if .tag is from_write.\n * @property {FilesWriteError} [to] - Available if .tag is to.\n * @property {('from_lookup'|'from_write'|'to'|'cant_copy_shared_folder'|'cant_nest_shared_folder'|'cant_move_folder_into_itself'|'too_many_files'|'duplicated_or_nested_paths'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} FilesRelocationPath\n * @property {string} from_path - Path in the user's Dropbox to be copied or\n * moved.\n * @property {string} to_path - Path in the user's Dropbox that is the\n * destination.\n */\n\n/**\n * @typedef {Object} FilesRelocationResult\n * @property {(FilesFileMetadata|FilesFolderMetadata|FilesDeletedMetadata)}\n * metadata\n */\n\n/**\n * @typedef {Object} FilesRemovePropertiesArg\n * @property {string} path - A unique identifier for the file.\n * @property {Array.<Object>} property_template_ids - A list of identifiers for\n * a property template created by route properties/template/add.\n */\n\n/**\n * @typedef {Object} FilesRemovePropertiesError\n * @property {string} [template_not_found] - Available if .tag is\n * template_not_found. Property template does not exist for given identifier.\n * @property {FilesLookupError} [path] - Available if .tag is path.\n * @property {FilesLookUpPropertiesError} [property_group_lookup] - Available if\n * .tag is property_group_lookup.\n * @property {('template_not_found'|'restricted_content'|'other'|'path'|'property_group_lookup')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} FilesRestoreArg\n * @property {string} path - The path to the file you want to restore.\n * @property {string} rev - The revision to restore for the file.\n */\n\n/**\n * @typedef {Object} FilesRestoreError\n * @property {FilesLookupError} [path_lookup] - Available if .tag is\n * path_lookup. An error occurs when downloading metadata for the file.\n * @property {FilesWriteError} [path_write] - Available if .tag is path_write.\n * An error occurs when trying to restore the file to that path.\n * @property {('path_lookup'|'path_write'|'invalid_revision'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} FilesSaveCopyReferenceArg\n * @property {string} copy_reference - A copy reference returned by\n * copy_reference/get.\n * @property {string} path - Path in the user's Dropbox that is the destination.\n */\n\n/**\n * @typedef {Object} FilesSaveCopyReferenceError\n * @property {FilesWriteError} [path] - Available if .tag is path.\n * @property {('path'|'invalid_copy_reference'|'no_permission'|'not_found'|'too_many_files'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} FilesSaveCopyReferenceResult\n * @property {(FilesFileMetadata|FilesFolderMetadata|FilesDeletedMetadata)}\n * metadata - The metadata of the saved file or folder in the user's Dropbox.\n */\n\n/**\n * @typedef {Object} FilesSaveUrlArg\n * @property {string} path - The path in Dropbox where the URL will be saved to.\n * @property {string} url - The URL to be saved.\n */\n\n/**\n * @typedef {Object} FilesSaveUrlError\n * @property {FilesWriteError} [path] - Available if .tag is path.\n * @property {('path'|'download_failed'|'invalid_url'|'not_found'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} FilesSaveUrlJobStatus\n * @property {FilesFileMetadata} [complete] - Available if .tag is complete.\n * Metadata of the file where the URL is saved to.\n * @property {FilesSaveUrlError} [failed] - Available if .tag is failed.\n * @property {('in_progress'|'complete'|'failed')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} FilesSaveUrlResult\n * @property {string} [async_job_id] - Available if .tag is async_job_id. This\n * response indicates that the processing is asynchronous. The string is an id\n * that can be used to obtain the status of the asynchronous job.\n * @property {FilesFileMetadata} [complete] - Available if .tag is complete.\n * Metadata of the file where the URL is saved to.\n * @property {('async_job_id'|'complete')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} FilesSearchArg\n * @property {string} path - The path in the user's Dropbox to search. Should\n * probably be a folder.\n * @property {string} query - The string to search for. The search string is\n * split on spaces into multiple tokens. For file name searching, the last token\n * is used for prefix matching (i.e. \"bat c\" matches \"bat cave\" but not \"batman\n * car\").\n * @property {number} start - The starting index within the search results (used\n * for paging).\n * @property {number} max_results - The maximum number of search results to\n * return.\n * @property {FilesSearchMode} mode - The search mode (filename,\n * filename_and_content, or deleted_filename). Note that searching file content\n * is only available for Dropbox Business accounts.\n */\n\n/**\n * @typedef {Object} FilesSearchError\n * @property {FilesLookupError} [path] - Available if .tag is path.\n * @property {('path'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} FilesSearchMatch\n * @property {FilesSearchMatchType} match_type - The type of the match.\n * @property {(FilesFileMetadata|FilesFolderMetadata|FilesDeletedMetadata)}\n * metadata - The metadata for the matched file or folder.\n */\n\n/**\n * Indicates what type of match was found for a given item.\n * @typedef {Object} FilesSearchMatchType\n * @property {('filename'|'content'|'both')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} FilesSearchMode\n * @property {('filename'|'filename_and_content'|'deleted_filename')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} FilesSearchResult\n * @property {Array.<FilesSearchMatch>} matches - A list (possibly empty) of\n * matches for the query.\n * @property {boolean} more - Used for paging. If true, indicates there is\n * another page of results available that can be fetched by calling search\n * again.\n * @property {number} start - Used for paging. Value to set the start argument\n * to when calling search to fetch the next page of results.\n */\n\n/**\n * Sharing info for a file or folder.\n * @typedef {Object} FilesSharingInfo\n * @property {boolean} read_only - True if the file or folder is inside a\n * read-only shared folder.\n */\n\n/**\n * @typedef {Object} FilesThumbnailArg\n * @property {string} path - The path to the image file you want to thumbnail.\n * @property {FilesThumbnailFormat} format - The format for the thumbnail image,\n * jpeg (default) or png. For  images that are photos, jpeg should be preferred,\n * while png is  better for screenshots and digital arts.\n * @property {FilesThumbnailSize} size - The size for the thumbnail image.\n */\n\n/**\n * @typedef {Object} FilesThumbnailError\n * @property {FilesLookupError} [path] - Available if .tag is path. An error\n * occurs when downloading metadata for the image.\n * @property {('path'|'unsupported_extension'|'unsupported_image'|'conversion_error')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} FilesThumbnailFormat\n * @property {('jpeg'|'png')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} FilesThumbnailSize\n * @property {('w32h32'|'w64h64'|'w128h128'|'w640h480'|'w1024h768')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} FilesUpdatePropertiesError\n * @property {string} [template_not_found] - Available if .tag is\n * template_not_found. Property template does not exist for given identifier.\n * @property {FilesLookupError} [path] - Available if .tag is path.\n * @property {FilesLookUpPropertiesError} [property_group_lookup] - Available if\n * .tag is property_group_lookup.\n * @property {('template_not_found'|'restricted_content'|'other'|'path'|'property_field_too_large'|'does_not_fit_template'|'property_group_lookup')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} FilesUpdatePropertyGroupArg\n * @property {string} path - A unique identifier for the file.\n * @property {Array.<FilesPropertyGroupUpdate>} update_property_groups - Filled\n * custom property templates associated with a file.\n */\n\n/**\n * @typedef {Object} FilesUploadError\n * @property {FilesUploadWriteFailed} [path] - Available if .tag is path. Unable\n * to save the uploaded contents to a file.\n * @property {('path'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} FilesUploadErrorWithProperties\n * @property {FilesUploadWriteFailed} [path] - Available if .tag is path. Unable\n * to save the uploaded contents to a file.\n * @property {FilesInvalidPropertyGroupError} [properties_error] - Available if\n * .tag is properties_error.\n * @property {('path'|'other'|'properties_error')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} FilesUploadSessionAppendArg\n * @property {Object} contents - The file contents to be uploaded.\n * @property {FilesUploadSessionCursor} cursor - Contains the upload session ID\n * and the offset.\n * @property {boolean} close - If true, the current session will be closed, at\n * which point you won't be able to call upload_session/append_v2 anymore with\n * the current session.\n */\n\n/**\n * @typedef {Object} FilesUploadSessionCursor\n * @property {Object} contents - The file contents to be uploaded.\n * @property {string} session_id - The upload session ID (returned by\n * upload_session/start).\n * @property {number} offset - The amount of data that has been uploaded so far.\n * We use this to make sure upload data isn't lost or duplicated in the event of\n * a network error.\n */\n\n/**\n * @typedef {Object} FilesUploadSessionFinishArg\n * @property {Object} contents - The file contents to be uploaded.\n * @property {FilesUploadSessionCursor} cursor - Contains the upload session ID\n * and the offset.\n * @property {FilesCommitInfo} commit - Contains the path and other optional\n * modifiers for the commit.\n */\n\n/**\n * @typedef {Object} FilesUploadSessionFinishBatchArg\n * @property {Array.<FilesUploadSessionFinishArg>} entries - Commit information\n * for each file in the batch.\n */\n\n/**\n * @typedef {Object} FilesUploadSessionFinishBatchJobStatus\n * @property {FilesUploadSessionFinishBatchResult} [complete] - Available if\n * .tag is complete. The :route:`upload_session/finish_batch` has finished.\n * @property {('in_progress'|'complete')} .tag - Tag identifying the union variant.\n */\n\n/**\n * Result returned by upload_session/finish_batch that may either launch an\n * asynchronous job or complete synchronously.\n * @typedef {Object} FilesUploadSessionFinishBatchLaunch\n * @property {string} [async_job_id] - Available if .tag is async_job_id. This\n * response indicates that the processing is asynchronous. The string is an id\n * that can be used to obtain the status of the asynchronous job.\n * @property {FilesUploadSessionFinishBatchResult} [complete] - Available if\n * .tag is complete.\n * @property {('async_job_id'|'complete'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} FilesUploadSessionFinishBatchResult\n * @property {Array.<FilesUploadSessionFinishBatchResultEntry>} entries - Commit\n * result for each file in the batch.\n */\n\n/**\n * @typedef {Object} FilesUploadSessionFinishBatchResultEntry\n * @property {FilesFileMetadata} [success] - Available if .tag is success.\n * @property {FilesUploadSessionFinishError} [failure] - Available if .tag is\n * failure.\n * @property {('success'|'failure')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} FilesUploadSessionFinishError\n * @property {FilesUploadSessionLookupError} [lookup_failed] - Available if .tag\n * is lookup_failed. The session arguments are incorrect; the value explains the\n * reason.\n * @property {FilesWriteError} [path] - Available if .tag is path. Unable to\n * save the uploaded contents to a file.\n * @property {('lookup_failed'|'path'|'too_many_shared_folder_targets'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} FilesUploadSessionLookupError\n * @property {FilesUploadSessionOffsetError} [incorrect_offset] - Available if\n * .tag is incorrect_offset. The specified offset was incorrect. See the value\n * for the correct offset. This error may occur when a previous request was\n * received and processed successfully but the client did not receive the\n * response, e.g. due to a network error.\n * @property {('not_found'|'incorrect_offset'|'closed'|'not_closed'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} FilesUploadSessionOffsetError\n * @property {number} correct_offset - The offset up to which data has been\n * collected.\n */\n\n/**\n * @typedef {Object} FilesUploadSessionStartArg\n * @property {Object} contents - The file contents to be uploaded.\n * @property {boolean} close - If true, the current session will be closed, at\n * which point you won't be able to call upload_session/append_v2 anymore with\n * the current session.\n */\n\n/**\n * @typedef {Object} FilesUploadSessionStartResult\n * @property {string} session_id - A unique identifier for the upload session.\n * Pass this to upload_session/append_v2 and upload_session/finish.\n */\n\n/**\n * @typedef {Object} FilesUploadWriteFailed\n * @property {FilesWriteError} reason - The reason why the file couldn't be\n * saved.\n * @property {string} upload_session_id - The upload session ID; this may be\n * used to retry the commit.\n */\n\n/**\n * Metadata for a video.\n * @typedef {Object} FilesVideoMetadata\n@property {'video'} [.tag] - Tag identifying this subtype variant. This field is\nonly present when needed to discriminate between multiple possible subtypes.\n * @property {FilesDimensions} [dimensions] - Dimension of the photo/video.\n * @property {FilesGpsCoordinates} [location] - The GPS coordinate of the\n * photo/video.\n * @property {Timestamp} [time_taken] - The timestamp when the photo/video is\n * taken.\n * @property {number} [duration] - The duration of the video in milliseconds.\n */\n\n/**\n * @typedef {Object} FilesWriteConflictError\n * @property {('file'|'folder'|'file_ancestor'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} FilesWriteError\n * @property {string} [malformed_path] - Available if .tag is malformed_path.\n * @property {FilesWriteConflictError} [conflict] - Available if .tag is\n * conflict. Couldn't write to the target path because there was something in\n * the way.\n * @property {('malformed_path'|'conflict'|'no_write_permission'|'insufficient_space'|'disallowed_name'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * Your intent when writing a file to some path. This is used to determine what\n * constitutes a conflict and what the autorename strategy is. In some\n * situations, the conflict behavior is identical: (a) If the target path\n * doesn't contain anything, the file is always written; no conflict. (b) If the\n * target path contains a folder, it's always a conflict. (c) If the target path\n * contains a file with identical contents, nothing gets written; no conflict.\n * The conflict checking differs in the case where there's a file at the target\n * path with contents different from the contents you're trying to write.\n * @typedef {Object} FilesWriteMode\n * @property {string} [update] - Available if .tag is update. Overwrite if the\n * given \"rev\" matches the existing file's \"rev\". The autorename strategy is to\n * append the string \"conflicted copy\" to the file name. For example,\n * \"document.txt\" might become \"document (conflicted copy).txt\" or \"document\n * (Panda's conflicted copy).txt\".\n * @property {('add'|'overwrite'|'update')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} PaperAddMember\n * @property {SharingMemberSelector} member - User which should be added to the\n * Paper doc. Specify only email or Dropbox account id.\n * @property {PaperPaperDocPermissionLevel} permission_level - Permission for\n * the user.\n */\n\n/**\n * @typedef {Object} PaperAddPaperDocUser\n * @property {string} doc_id\n * @property {Array.<PaperAddMember>} members - User which should be added to\n * the Paper doc. Specify only email or Dropbox account id.\n * @property {string} [custom_message] - A personal message that will be emailed\n * to each successfully added member.\n * @property {boolean} quiet - Clients should set this to true if no email shall\n * be sent to added users.\n */\n\n/**\n * Per-member result for docs/users/add.\n * @typedef {Object} PaperAddPaperDocUserMemberResult\n * @property {SharingMemberSelector} member - One of specified input members.\n * @property {PaperAddPaperDocUserResult} result - The outcome of the action on\n * this member.\n */\n\n/**\n * @typedef {Object} PaperAddPaperDocUserResult\n * @property {('success'|'unknown_error'|'sharing_outside_team_disabled'|'daily_limit_reached'|'user_is_owner'|'failed_user_data_retrieval'|'permission_already_granted'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} PaperCursor\n * @property {string} value - The actual cursor value.\n * @property {Timestamp} [expiration] - Expiration time of value. Some cursors\n * might have expiration time assigned. This is a UTC value after which the\n * cursor is no longer valid and the API starts returning an error. If cursor\n * expires a new one needs to be obtained and pagination needs to be restarted.\n * Some cursors might be short-lived some cursors might be long-lived. This\n * really depends on the sorting type and order, e.g.: 1. on one hand, listing\n * docs created by the user, sorted by the created time ascending will have\n * undefinite expiration because the results cannot change while the iteration\n * is happening. This cursor would be suitable for long term polling. 2. on the\n * other hand, listing docs sorted by the last modified time will have a very\n * short expiration as docs do get modified very often and the modified time can\n * be changed while the iteration is happening thus altering the results.\n */\n\n/**\n * @typedef {Object} PaperDocLookupError\n * @property {('insufficient_permissions'|'other'|'doc_not_found')} .tag - Tag identifying the union variant.\n */\n\n/**\n * The subscription level of a Paper doc.\n * @typedef {Object} PaperDocSubscriptionLevel\n * @property {('default'|'ignore'|'every'|'no_email')} .tag - Tag identifying the union variant.\n */\n\n/**\n * The desired export format of the Paper doc.\n * @typedef {Object} PaperExportFormat\n * @property {('html'|'markdown'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * Data structure representing a Paper folder.\n * @typedef {Object} PaperFolder\n * @property {string} id - Paper folder id. This id uniquely identifies the\n * folder.\n * @property {string} name - Paper folder name.\n */\n\n/**\n * The sharing policy of a Paper folder.  Note: The sharing policy of subfolders\n * is inherited from the root folder.\n * @typedef {Object} PaperFolderSharingPolicyType\n * @property {('team'|'invite_only')} .tag - Tag identifying the union variant.\n */\n\n/**\n * The subscription level of a Paper folder.\n * @typedef {Object} PaperFolderSubscriptionLevel\n * @property {('none'|'activity_only'|'daily_emails'|'weekly_emails')} .tag - Tag identifying the union variant.\n */\n\n/**\n * Metadata about Paper folders containing the specififed Paper doc.\n * @typedef {Object} PaperFoldersContainingPaperDoc\n * @property {PaperFolderSharingPolicyType} [folder_sharing_policy_type] - The\n * sharing policy of the folder containing the Paper doc.\n * @property {Array.<PaperFolder>} [folders] - The folder path. If present the\n * first folder is the root folder.\n */\n\n/**\n * @typedef {Object} PaperInviteeInfoWithPermissionLevel\n * @property {SharingInviteeInfo} invitee - Email invited to the Paper doc.\n * @property {PaperPaperDocPermissionLevel} permission_level - Permission level\n * for the invitee.\n */\n\n/**\n * @typedef {Object} PaperListDocsCursorError\n * @property {PaperPaperApiCursorError} [cursor_error] - Available if .tag is\n * cursor_error.\n * @property {('cursor_error'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} PaperListPaperDocsArgs\n * @property {PaperListPaperDocsFilterBy} filter_by - Allows user to specify how\n * the Paper docs should be filtered.\n * @property {PaperListPaperDocsSortBy} sort_by - Allows user to specify how the\n * Paper docs should be sorted.\n * @property {PaperListPaperDocsSortOrder} sort_order - Allows user to specify\n * the sort order of the result.\n * @property {number} limit - Size limit per batch. The maximum number of docs\n * that can be retrieved per batch is 1000. Higher value results in invalid\n * arguments error.\n */\n\n/**\n * @typedef {Object} PaperListPaperDocsContinueArgs\n * @property {string} cursor - The cursor obtained from docs/list or\n * docs/list/continue. Allows for pagination.\n */\n\n/**\n * @typedef {Object} PaperListPaperDocsFilterBy\n * @property {('docs_accessed'|'docs_created'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} PaperListPaperDocsResponse\n * @property {Array.<string>} doc_ids - The list of Paper doc ids that can be\n * used to access the given Paper docs or supplied to other API methods. The\n * list is sorted in the order specified by the initial call to docs/list.\n * @property {PaperCursor} cursor - Pass the cursor into docs/list/continue to\n * paginate through all files. The cursor preserves all properties as specified\n * in the original call to docs/list.\n * @property {boolean} has_more - Will be set to True if a subsequent call with\n * the provided cursor to docs/list/continue returns immediately with some\n * results. If set to False please allow some delay before making another call\n * to docs/list/continue.\n */\n\n/**\n * @typedef {Object} PaperListPaperDocsSortBy\n * @property {('accessed'|'modified'|'created'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} PaperListPaperDocsSortOrder\n * @property {('ascending'|'descending'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} PaperListUsersCursorError\n * @property {PaperPaperApiCursorError} [cursor_error] - Available if .tag is\n * cursor_error.\n * @property {('insufficient_permissions'|'other'|'doc_not_found'|'cursor_error')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} PaperListUsersOnFolderArgs\n * @property {string} doc_id\n * @property {number} limit - Size limit per batch. The maximum number of users\n * that can be retrieved per batch is 1000. Higher value results in invalid\n * arguments error.\n */\n\n/**\n * @typedef {Object} PaperListUsersOnFolderContinueArgs\n * @property {string} doc_id\n * @property {string} cursor - The cursor obtained from docs/folder_users/list\n * or docs/folder_users/list/continue. Allows for pagination.\n */\n\n/**\n * @typedef {Object} PaperListUsersOnFolderResponse\n * @property {Array.<SharingInviteeInfo>} invitees - List of email addresses\n * that are invited on the Paper folder.\n * @property {Array.<SharingUserInfo>} users - List of users that are invited on\n * the Paper folder.\n * @property {PaperCursor} cursor - Pass the cursor into\n * docs/folder_users/list/continue to paginate through all users. The cursor\n * preserves all properties as specified in the original call to\n * docs/folder_users/list.\n * @property {boolean} has_more - Will be set to True if a subsequent call with\n * the provided cursor to docs/folder_users/list/continue returns immediately\n * with some results. If set to False please allow some delay before making\n * another call to docs/folder_users/list/continue.\n */\n\n/**\n * @typedef {Object} PaperListUsersOnPaperDocArgs\n * @property {string} doc_id\n * @property {number} limit - Size limit per batch. The maximum number of users\n * that can be retrieved per batch is 1000. Higher value results in invalid\n * arguments error.\n * @property {PaperUserOnPaperDocFilter} filter_by - Specify this attribute if\n * you want to obtain users that have already accessed the Paper doc.\n */\n\n/**\n * @typedef {Object} PaperListUsersOnPaperDocContinueArgs\n * @property {string} doc_id\n * @property {string} cursor - The cursor obtained from docs/users/list or\n * docs/users/list/continue. Allows for pagination.\n */\n\n/**\n * @typedef {Object} PaperListUsersOnPaperDocResponse\n * @property {Array.<PaperInviteeInfoWithPermissionLevel>} invitees - List of\n * email addresses with their respective permission levels that are invited on\n * the Paper doc.\n * @property {Array.<PaperUserInfoWithPermissionLevel>} users - List of users\n * with their respective permission levels that are invited on the Paper folder.\n * @property {SharingUserInfo} doc_owner - The Paper doc owner. This field is\n * populated on every single response.\n * @property {PaperCursor} cursor - Pass the cursor into\n * docs/users/list/continue to paginate through all users. The cursor preserves\n * all properties as specified in the original call to docs/users/list.\n * @property {boolean} has_more - Will be set to True if a subsequent call with\n * the provided cursor to docs/users/list/continue returns immediately with some\n * results. If set to False please allow some delay before making another call\n * to docs/users/list/continue.\n */\n\n/**\n * @typedef {Object} PaperPaperApiBaseError\n * @property {('insufficient_permissions'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} PaperPaperApiCursorError\n * @property {('expired_cursor'|'invalid_cursor'|'wrong_user_in_cursor'|'reset'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} PaperPaperDocExport\n * @property {string} doc_id\n * @property {PaperExportFormat} export_format\n */\n\n/**\n * @typedef {Object} PaperPaperDocExportResult\n * @property {string} owner - The Paper doc owner's email.\n * @property {string} title - The Paper doc title.\n * @property {number} revision - The Paper doc revision. Simply an ever\n * increasing number.\n * @property {string} mime_type - MIME type of the export. This corresponds to\n * ExportFormat specified in the request.\n */\n\n/**\n * @typedef {Object} PaperPaperDocPermissionLevel\n * @property {('edit'|'view_and_comment'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} PaperPaperDocSharingPolicy\n * @property {string} doc_id\n * @property {PaperSharingPolicy} sharing_policy - The default sharing policy to\n * be set for the Paper doc.\n */\n\n/**\n * @typedef {Object} PaperRefPaperDoc\n * @property {string} doc_id\n */\n\n/**\n * @typedef {Object} PaperRemovePaperDocUser\n * @property {string} doc_id\n * @property {SharingMemberSelector} member - User which should be removed from\n * the Paper doc. Specify only email or Dropbox account id.\n */\n\n/**\n * Sharing policy of Paper doc.\n * @typedef {Object} PaperSharingPolicy\n * @property {PaperSharingPublicPolicyType} [public_sharing_policy] - This value\n * applies to the non-team members.\n * @property {PaperSharingTeamPolicyType} [team_sharing_policy] - This value\n * applies to the team members only. The value is null for all personal\n * accounts.\n */\n\n/**\n * @typedef {Object} PaperSharingPublicPolicyType\n * @property {('people_with_link_can_edit'|'people_with_link_can_view_and_comment'|'invite_only'|'disabled')} .tag - Tag identifying the union variant.\n */\n\n/**\n * The sharing policy type of the Paper doc.\n * @typedef {Object} PaperSharingTeamPolicyType\n * @property {('people_with_link_can_edit'|'people_with_link_can_view_and_comment'|'invite_only')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} PaperUserInfoWithPermissionLevel\n * @property {SharingUserInfo} user - User shared on the Paper doc.\n * @property {PaperPaperDocPermissionLevel} permission_level - Permission level\n * for the user.\n */\n\n/**\n * @typedef {Object} PaperUserOnPaperDocFilter\n * @property {('visited'|'shared'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} PropertiesGetPropertyTemplateArg\n * @property {string} template_id - An identifier for property template added by\n * route properties/template/add.\n */\n\n/**\n * The Property template for the specified template.\n * @typedef {Object} PropertiesGetPropertyTemplateResult\n * @property {string} name - A display name for the property template. Property\n * template names can be up to 256 bytes.\n * @property {string} description - Description for new property template.\n * Property template descriptions can be up to 1024 bytes.\n * @property {Array.<PropertiesPropertyFieldTemplate>} fields - This is a list\n * of custom properties associated with a property template. There can be up to\n * 64 properties in a single property template.\n */\n\n/**\n * @typedef {Object} PropertiesListPropertyTemplateIds\n * @property {Array.<Object>} template_ids - List of identifiers for templates\n * added by route properties/template/add.\n */\n\n/**\n * @typedef {Object} PropertiesModifyPropertyTemplateError\n * @property {string} [template_not_found] - Available if .tag is\n * template_not_found. Property template does not exist for given identifier.\n * @property {('template_not_found'|'restricted_content'|'other'|'conflicting_property_names'|'too_many_properties'|'too_many_templates'|'template_attribute_too_large')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} PropertiesPropertyField\n * @property {string} name - This is the name or key of a custom property in a\n * property template. File property names can be up to 256 bytes.\n * @property {string} value - Value of a custom property attached to a file.\n * Values can be up to 1024 bytes.\n */\n\n/**\n * Describe a single property field type which that can be part of a property\n * template.\n * @typedef {Object} PropertiesPropertyFieldTemplate\n * @property {string} name - This is the name or key of a custom property in a\n * property template. File property names can be up to 256 bytes.\n * @property {string} description - This is the description for a custom\n * property in a property template. File property description can be up to 1024\n * bytes.\n * @property {PropertiesPropertyType} type - This is the data type of the value\n * of this property. This type will be enforced upon property creation and\n * modifications.\n */\n\n/**\n * Collection of custom properties in filled property templates.\n * @typedef {Object} PropertiesPropertyGroup\n * @property {string} template_id - A unique identifier for a property template\n * type.\n * @property {Array.<PropertiesPropertyField>} fields - This is a list of custom\n * properties associated with a file. There can be up to 32 properties for a\n * template.\n */\n\n/**\n * Describes property templates that can be filled and associated with a file.\n * @typedef {Object} PropertiesPropertyGroupTemplate\n * @property {string} name - A display name for the property template. Property\n * template names can be up to 256 bytes.\n * @property {string} description - Description for new property template.\n * Property template descriptions can be up to 1024 bytes.\n * @property {Array.<PropertiesPropertyFieldTemplate>} fields - This is a list\n * of custom properties associated with a property template. There can be up to\n * 64 properties in a single property template.\n */\n\n/**\n * @typedef {Object} PropertiesPropertyTemplateError\n * @property {string} [template_not_found] - Available if .tag is\n * template_not_found. Property template does not exist for given identifier.\n * @property {('template_not_found'|'restricted_content'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * Data type of the given property added. This endpoint is in beta and  only\n * properties of type strings is supported.\n * @typedef {Object} PropertiesPropertyType\n * @property {('string'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * Defines the access levels for collaborators.\n * @typedef {Object} SharingAccessLevel\n * @property {('owner'|'editor'|'viewer'|'viewer_no_comment'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * Who can change a shared folder's access control list (ACL). In other words,\n * who can add, remove, or change the privileges of members.\n * @typedef {Object} SharingAclUpdatePolicy\n * @property {('owner'|'editors'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * Arguments for add_file_member.\n * @typedef {Object} SharingAddFileMemberArgs\n * @property {string} file - File to which to add members.\n * @property {Array.<SharingMemberSelector>} members - Members to add. Note that\n * even an email address is given, this may result in a user being directy added\n * to the membership if that email is the user's main account email.\n * @property {string} [custom_message] - Message to send to added members in\n * their invitation.\n * @property {boolean} quiet - Whether added members should be notified via\n * device notifications of their invitation.\n * @property {SharingAccessLevel} access_level - AccessLevel union object,\n * describing what access level we want to give new members.\n * @property {boolean} add_message_as_comment - If the custom message should be\n * added as a comment on the file.\n */\n\n/**\n * Errors for add_file_member.\n * @typedef {Object} SharingAddFileMemberError\n * @property {SharingSharingUserError} [user_error] - Available if .tag is\n * user_error.\n * @property {SharingSharingFileAccessError} [access_error] - Available if .tag\n * is access_error.\n * @property {('user_error'|'access_error'|'rate_limit'|'invalid_comment'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} SharingAddFolderMemberArg\n * @property {string} shared_folder_id - The ID for the shared folder.\n * @property {Array.<SharingAddMember>} members - The intended list of members\n * to add.  Added members will receive invites to join the shared folder.\n * @property {boolean} quiet - Whether added members should be notified via\n * email and device notifications of their invite.\n * @property {string} [custom_message] - Optional message to display to added\n * members in their invitation.\n */\n\n/**\n * @typedef {Object} SharingAddFolderMemberError\n * @property {SharingSharedFolderAccessError} [access_error] - Available if .tag\n * is access_error. Unable to access shared folder.\n * @property {SharingAddMemberSelectorError} [bad_member] - Available if .tag is\n * bad_member. :field:`AddFolderMemberArg.members` contains a bad invitation\n * recipient.\n * @property {number} [too_many_members] - Available if .tag is\n * too_many_members. The value is the member limit that was reached.\n * @property {number} [too_many_pending_invites] - Available if .tag is\n * too_many_pending_invites. The value is the pending invite limit that was\n * reached.\n * @property {('access_error'|'email_unverified'|'bad_member'|'cant_share_outside_team'|'too_many_members'|'too_many_pending_invites'|'rate_limit'|'too_many_invitees'|'insufficient_plan'|'team_folder'|'no_permission'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * The member and type of access the member should have when added to a shared\n * folder.\n * @typedef {Object} SharingAddMember\n * @property {SharingMemberSelector} member - The member to add to the shared\n * folder.\n * @property {SharingAccessLevel} access_level - The access level to grant\n * member to the shared folder.  AccessLevel.owner is disallowed.\n */\n\n/**\n * @typedef {Object} SharingAddMemberSelectorError\n * @property {string} [invalid_dropbox_id] - Available if .tag is\n * invalid_dropbox_id. The value is the ID that could not be identified.\n * @property {string} [invalid_email] - Available if .tag is invalid_email. The\n * value is the e-email address that is malformed.\n * @property {string} [unverified_dropbox_id] - Available if .tag is\n * unverified_dropbox_id. The value is the ID of the Dropbox user with an\n * unverified e-mail address.  Invite unverified users by e-mail address instead\n * of by their Dropbox ID.\n * @property {('automatic_group'|'invalid_dropbox_id'|'invalid_email'|'unverified_dropbox_id'|'group_deleted'|'group_not_on_team'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * Arguments for change_file_member_access.\n * @typedef {Object} SharingChangeFileMemberAccessArgs\n * @property {string} file - File for which we are changing a member's access.\n * @property {SharingMemberSelector} member - The member whose access we are\n * changing.\n * @property {SharingAccessLevel} access_level - The new access level for the\n * member.\n */\n\n/**\n * Metadata for a collection-based shared link.\n * @typedef {Object} SharingCollectionLinkMetadata\n@property {'collection'} [.tag] - Tag identifying this subtype variant. This\nfield is only present when needed to discriminate between multiple possible\nsubtypes.\n * @property {string} url - URL of the shared link.\n * @property {SharingVisibility} visibility - Who can access the link.\n * @property {Timestamp} [expires] - Expiration time, if set. By default the\n * link won't expire.\n */\n\n/**\n * @typedef {Object} SharingCreateSharedLinkArg\n * @property {string} path - The path to share.\n * @property {boolean} short_url - Whether to return a shortened URL.\n * @property {SharingPendingUploadMode} [pending_upload] - If it's okay to share\n * a path that does not yet exist, set this to either PendingUploadMode.file or\n * PendingUploadMode.folder to indicate whether to assume it's a file or folder.\n */\n\n/**\n * @typedef {Object} SharingCreateSharedLinkError\n * @property {FilesLookupError} [path] - Available if .tag is path.\n * @property {('path'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} SharingCreateSharedLinkWithSettingsArg\n * @property {string} path - The path to be shared by the shared link\n * @property {SharingSharedLinkSettings} [settings] - The requested settings for\n * the newly created shared link\n */\n\n/**\n * @typedef {Object} SharingCreateSharedLinkWithSettingsError\n * @property {FilesLookupError} [path] - Available if .tag is path.\n * @property {SharingSharedLinkSettingsError} [settings_error] - Available if\n * .tag is settings_error. There is an error with the given settings\n * @property {('path'|'email_not_verified'|'shared_link_already_exists'|'settings_error'|'access_denied')} .tag - Tag identifying the union variant.\n */\n\n/**\n * Sharing actions that may be taken on files.\n * @typedef {Object} SharingFileAction\n * @property {('disable_viewer_info'|'edit_contents'|'enable_viewer_info'|'invite_viewer'|'invite_viewer_no_comment'|'unshare'|'relinquish_membership'|'share_link'|'create_link'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} SharingFileErrorResult\n * @property {string} [file_not_found_error] - Available if .tag is\n * file_not_found_error. File specified by id was not found.\n * @property {string} [invalid_file_action_error] - Available if .tag is\n * invalid_file_action_error. User does not have permission to take the\n * specified action on the file.\n * @property {string} [permission_denied_error] - Available if .tag is\n * permission_denied_error. User does not have permission to access file\n * specified by file.Id.\n * @property {('file_not_found_error'|'invalid_file_action_error'|'permission_denied_error'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * The metadata of a file shared link\n * @typedef {Object} SharingFileLinkMetadata\n@property {'file'} [.tag] - Tag identifying this subtype variant. This field is\nonly present when needed to discriminate between multiple possible subtypes.\n * @property {string} url - URL of the shared link.\n * @property {string} name - The linked file name (including extension). This\n * never contains a slash.\n * @property {SharingLinkPermissions} link_permissions - The link's access\n * permissions.\n * @property {Timestamp} client_modified - The modification time set by the\n * desktop client when the file was added to Dropbox. Since this time is not\n * verified (the Dropbox server stores whatever the desktop client sends up),\n * this should only be used for display purposes (such as sorting) and not, for\n * example, to determine if a file has changed or not.\n * @property {Timestamp} server_modified - The last time the file was modified\n * on Dropbox.\n * @property {string} rev - A unique identifier for the current revision of a\n * file. This field is the same rev as elsewhere in the API and can be used to\n * detect changes and avoid conflicts.\n * @property {number} size - The file size in bytes.\n * @property {string} [id] - A unique identifier for the linked file.\n * @property {Timestamp} [expires] - Expiration time, if set. By default the\n * link won't expire.\n * @property {string} [path_lower] - The lowercased full path in the user's\n * Dropbox. This always starts with a slash. This field will only be present\n * only if the linked file is in the authenticated user's  dropbox.\n * @property {SharingTeamMemberInfo} [team_member_info] - The team membership\n * information of the link's owner.  This field will only be present  if the\n * link's owner is a team member.\n * @property {UsersTeam} [content_owner_team_info] - The team information of the\n * content's owner. This field will only be present if the content's owner is a\n * team member and the content's owner team is different from the link's owner\n * team.\n */\n\n/**\n * @typedef {Object} SharingFileMemberActionError\n * @property {SharingSharingFileAccessError} [access_error] - Available if .tag\n * is access_error. Specified file was invalid or user does not have access.\n * @property {SharingMemberAccessLevelResult} [no_explicit_access] - Available\n * if .tag is no_explicit_access. The action cannot be completed because the\n * target member does not have explicit access to the file. The return value is\n * the access that the member has to the file from a parent folder.\n * @property {('invalid_member'|'no_permission'|'access_error'|'no_explicit_access'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} SharingFileMemberActionIndividualResult\n * @property {SharingAccessLevel} [success] - Available if .tag is success.\n * Member was successfully removed from this file. If AccessLevel is given, the\n * member still has access via a parent shared folder.\n * @property {SharingFileMemberActionError} [member_error] - Available if .tag\n * is member_error. User was not able to perform this action.\n * @property {('success'|'member_error')} .tag - Tag identifying the union variant.\n */\n\n/**\n * Per-member result for add_file_member or change_file_member_access.\n * @typedef {Object} SharingFileMemberActionResult\n * @property {SharingMemberSelector} member - One of specified input members.\n * @property {SharingFileMemberActionIndividualResult} result - The outcome of\n * the action on this member.\n */\n\n/**\n * @typedef {Object} SharingFileMemberRemoveActionResult\n * @property {SharingMemberAccessLevelResult} [success] - Available if .tag is\n * success. Member was successfully removed from this file.\n * @property {SharingFileMemberActionError} [member_error] - Available if .tag\n * is member_error. User was not able to remove this member.\n * @property {('success'|'member_error'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * Whether the user is allowed to take the sharing action on the file.\n * @typedef {Object} SharingFilePermission\n * @property {SharingFileAction} action - The action that the user may wish to\n * take on the file.\n * @property {boolean} allow - True if the user is allowed to take the action.\n * @property {SharingPermissionDeniedReason} [reason] - The reason why the user\n * is denied the permission. Not present if the action is allowed.\n */\n\n/**\n * Actions that may be taken on shared folders.\n * @typedef {Object} SharingFolderAction\n * @property {('change_options'|'disable_viewer_info'|'edit_contents'|'enable_viewer_info'|'invite_editor'|'invite_viewer'|'invite_viewer_no_comment'|'relinquish_membership'|'unmount'|'unshare'|'leave_a_copy'|'share_link'|'create_link'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * The metadata of a folder shared link\n * @typedef {Object} SharingFolderLinkMetadata\n@property {'folder'} [.tag] - Tag identifying this subtype variant. This field\nis only present when needed to discriminate between multiple possible subtypes.\n * @property {string} url - URL of the shared link.\n * @property {string} name - The linked file name (including extension). This\n * never contains a slash.\n * @property {SharingLinkPermissions} link_permissions - The link's access\n * permissions.\n * @property {string} [id] - A unique identifier for the linked file.\n * @property {Timestamp} [expires] - Expiration time, if set. By default the\n * link won't expire.\n * @property {string} [path_lower] - The lowercased full path in the user's\n * Dropbox. This always starts with a slash. This field will only be present\n * only if the linked file is in the authenticated user's  dropbox.\n * @property {SharingTeamMemberInfo} [team_member_info] - The team membership\n * information of the link's owner.  This field will only be present  if the\n * link's owner is a team member.\n * @property {UsersTeam} [content_owner_team_info] - The team information of the\n * content's owner. This field will only be present if the content's owner is a\n * team member and the content's owner team is different from the link's owner\n * team.\n */\n\n/**\n * Whether the user is allowed to take the action on the shared folder.\n * @typedef {Object} SharingFolderPermission\n * @property {SharingFolderAction} action - The action that the user may wish to\n * take on the folder.\n * @property {boolean} allow - True if the user is allowed to take the action.\n * @property {SharingPermissionDeniedReason} [reason] - The reason why the user\n * is denied the permission. Not present if the action is allowed, or if no\n * reason is available.\n */\n\n/**\n * A set of policies governing membership and privileges for a shared folder.\n * @typedef {Object} SharingFolderPolicy\n * @property {SharingAclUpdatePolicy} acl_update_policy - Who can add and remove\n * members from this shared folder.\n * @property {SharingSharedLinkPolicy} shared_link_policy - Who links can be\n * shared with.\n * @property {SharingMemberPolicy} [member_policy] - Who can be a member of this\n * shared folder, as set on the folder itself. The effective policy may differ\n * from this value if the team-wide policy is more restrictive. Present only if\n * the folder is owned by a team.\n * @property {SharingMemberPolicy} [resolved_member_policy] - Who can be a\n * member of this shared folder, taking into account both the folder and the\n * team-wide policy. This value may differ from that of member_policy if the\n * team-wide policy is more restrictive than the folder policy. Present only if\n * the folder is owned by a team.\n * @property {SharingViewerInfoPolicy} [viewer_info_policy] - Who can\n * enable/disable viewer info for this shared folder.\n */\n\n/**\n * Arguments of get_file_metadata.\n * @typedef {Object} SharingGetFileMetadataArg\n * @property {string} file - The file to query.\n * @property {Array.<SharingFileAction>} [actions] - File actions to query.\n */\n\n/**\n * Arguments of get_file_metadata/batch.\n * @typedef {Object} SharingGetFileMetadataBatchArg\n * @property {Array.<Object>} files - The files to query.\n * @property {Array.<SharingFileAction>} [actions] - File actions to query.\n */\n\n/**\n * Per file results of get_file_metadata/batch.\n * @typedef {Object} SharingGetFileMetadataBatchResult\n * @property {string} file - This is the input file identifier corresponding to\n * one of GetFileMetadataBatchArg.files.\n * @property {SharingGetFileMetadataIndividualResult} result - The result for\n * this particular file.\n */\n\n/**\n * Error result for get_file_metadata.\n * @typedef {Object} SharingGetFileMetadataError\n * @property {SharingSharingUserError} [user_error] - Available if .tag is\n * user_error.\n * @property {SharingSharingFileAccessError} [access_error] - Available if .tag\n * is access_error.\n * @property {('user_error'|'access_error'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} SharingGetFileMetadataIndividualResult\n * @property {SharingSharedFileMetadata} [metadata] - Available if .tag is\n * metadata. The result for this file if it was successful.\n * @property {SharingSharingFileAccessError} [access_error] - Available if .tag\n * is access_error. The result for this file if it was an error.\n * @property {('metadata'|'access_error'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} SharingGetMetadataArgs\n * @property {string} shared_folder_id - The ID for the shared folder.\n * @property {Array.<SharingFolderAction>} [actions] - This is a list indicating\n * whether the returned folder data will include a boolean value\n * FolderPermission.allow that describes whether the current user can perform\n * the  FolderAction on the folder.\n */\n\n/**\n * @typedef {Object} SharingGetSharedLinkFileError\n * @property {('shared_link_not_found'|'shared_link_access_denied'|'unsupported_link_type'|'other'|'shared_link_is_directory')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} SharingGetSharedLinkMetadataArg\n * @property {string} url - URL of the shared link.\n * @property {string} [path] - If the shared link is to a folder, this parameter\n * can be used to retrieve the metadata for a specific file or sub-folder in\n * this folder. A relative path should be used.\n * @property {string} [link_password] - If the shared link has a password, this\n * parameter can be used.\n */\n\n/**\n * @typedef {Object} SharingGetSharedLinksArg\n * @property {string} [path] - See get_shared_links description.\n */\n\n/**\n * @typedef {Object} SharingGetSharedLinksError\n * @property {string} [path] - Available if .tag is path.\n * @property {('path'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} SharingGetSharedLinksResult\n * @property\n * {Array.<(SharingPathLinkMetadata|SharingCollectionLinkMetadata|SharingLinkMetadata)>}\n * links - Shared links applicable to the path argument.\n */\n\n/**\n * The information about a group. Groups is a way to manage a list of users  who\n * need same access permission to the shared folder.\n * @typedef {Object} SharingGroupInfo\n * @property {string} group_name\n * @property {string} group_id\n * @property {TeamCommonGroupManagementType} group_management_type - Who is\n * allowed to manage the group.\n * @property {TeamCommonGroupType} group_type - The type of group.\n * @property {boolean} is_member - If the current user is a member of the group.\n * @property {boolean} is_owner - If the current user is an owner of the group.\n * @property {boolean} same_team - If the group is owned by the current user's\n * team.\n * @property {string} [group_external_id] - External ID of group. This is an\n * arbitrary ID that an admin can attach to a group.\n * @property {number} [member_count] - The number of members in the group.\n */\n\n/**\n * The information about a group member of the shared content.\n * @typedef {Object} SharingGroupMembershipInfo\n * @property {SharingAccessLevel} access_type - The access type for this member.\n * @property {SharingGroupInfo} group - The information about the membership\n * group.\n * @property {Array.<SharingMemberPermission>} [permissions] - The permissions\n * that requesting user has on this member. The set of permissions corresponds\n * to the MemberActions in the request.\n * @property {string} [initials] - Suggested name initials for a member.\n * @property {boolean} is_inherited - True if the member has access from a\n * parent folder.\n */\n\n/**\n * @typedef {Object} SharingInsufficientQuotaAmounts\n * @property {number} space_needed - The amount of space needed to add the item\n * (the size of the item).\n * @property {number} space_shortage - The amount of extra space needed to add\n * the item.\n * @property {number} space_left - The amount of space left in the user's\n * Dropbox, less than space_needed.\n */\n\n/**\n * Information about the recipient of a shared content invitation.\n * @typedef {Object} SharingInviteeInfo\n * @property {string} [email] - Available if .tag is email. E-mail address of\n * invited user.\n * @property {('email'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * Information about an invited member of a shared content.\n * @typedef {Object} SharingInviteeMembershipInfo\n * @property {SharingAccessLevel} access_type - The access type for this member.\n * @property {SharingInviteeInfo} invitee - Recipient of the invitation.\n * @property {Array.<SharingMemberPermission>} [permissions] - The permissions\n * that requesting user has on this member. The set of permissions corresponds\n * to the MemberActions in the request.\n * @property {string} [initials] - Suggested name initials for a member.\n * @property {boolean} is_inherited - True if the member has access from a\n * parent folder.\n * @property {SharingUserInfo} [user] - The user this invitation is tied to, if\n * available.\n */\n\n/**\n * Error occurred while performing an asynchronous job from unshare_folder or\n * remove_folder_member.\n * @typedef {Object} SharingJobError\n * @property {SharingUnshareFolderError} [unshare_folder_error] - Available if\n * .tag is unshare_folder_error. Error occurred while performing\n * :route:`unshare_folder` action.\n * @property {SharingRemoveFolderMemberError} [remove_folder_member_error] -\n * Available if .tag is remove_folder_member_error. Error occurred while\n * performing :route:`remove_folder_member` action.\n * @property {SharingRelinquishFolderMembershipError}\n * [relinquish_folder_membership_error] - Available if .tag is\n * relinquish_folder_membership_error. Error occurred while performing\n * :route:`relinquish_folder_membership` action.\n * @property {('unshare_folder_error'|'remove_folder_member_error'|'relinquish_folder_membership_error'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} SharingJobStatus\n * @property {SharingJobError} [failed] - Available if .tag is failed. The\n * asynchronous job returned an error.\n * @property {('in_progress'|'complete'|'failed')} .tag - Tag identifying the union variant.\n */\n\n/**\n * Actions that can be performed on a link.\n * @typedef {Object} SharingLinkAction\n * @property {('change_audience'|'remove_expiry'|'remove_password'|'set_expiry'|'set_password'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} SharingLinkAudience\n * @property {('public'|'team'|'members'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} SharingLinkExpiry\n * @property {Timestamp} [set_expiry] - Available if .tag is set_expiry. Set a\n * new expiry or change an existing expiry.\n * @property {('remove_expiry'|'set_expiry'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * Metadata for a shared link. This can be either a PathLinkMetadata or\n * CollectionLinkMetadata.\n * @typedef {Object} SharingLinkMetadata\n@property {(\"path\"|\"collection\")} .tag - Tag identifying the subtype variant.\n * @property {string} url - URL of the shared link.\n * @property {SharingVisibility} visibility - Who can access the link.\n * @property {Timestamp} [expires] - Expiration time, if set. By default the\n * link won't expire.\n */\n\n/**\n * @typedef {Object} SharingLinkPassword\n * @property {string} [set_password] - Available if .tag is set_password. Set a\n * new password or change an existing password.\n * @property {('remove_password'|'set_password'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * Permissions for actions that can be performed on a link.\n * @typedef {Object} SharingLinkPermission\n * @property {SharingLinkAction} action\n * @property {boolean} allow\n * @property {SharingPermissionDeniedReason} [reason]\n */\n\n/**\n * @typedef {Object} SharingLinkPermissions\n * @property {boolean} can_revoke - Whether the caller can revoke the shared\n * link\n * @property {SharingResolvedVisibility} [resolved_visibility] - The current\n * visibility of the link after considering the shared links policies of the the\n * team (in case the link's owner is part of a team) and the shared folder (in\n * case the linked file is part of a shared folder). This field is shown only if\n * the caller has access to this info (the link's owner always has access to\n * this data).\n * @property {SharingRequestedVisibility} [requested_visibility] - The shared\n * link's requested visibility. This can be overridden by the team and shared\n * folder policies. The final visibility, after considering these policies, can\n * be found in resolved_visibility. This is shown only if the caller is the\n * link's owner.\n * @property {SharingSharedLinkAccessFailureReason} [revoke_failure_reason] -\n * The failure reason for revoking the link. This field will only be present if\n * the can_revoke is false.\n */\n\n/**\n * Settings that apply to a link.\n * @typedef {Object} SharingLinkSettings\n * @property {SharingLinkAudience} [audience] - The type of audience on the link\n * for this file.\n * @property {SharingLinkExpiry} [expiry] - An expiry timestamp to set on a\n * link.\n * @property {SharingLinkPassword} [password] - The password for the link.\n */\n\n/**\n * Arguments for list_file_members.\n * @typedef {Object} SharingListFileMembersArg\n * @property {string} file - The file for which you want to see members.\n * @property {Array.<SharingMemberAction>} [actions] - The actions for which to\n * return permissions on a member.\n * @property {boolean} include_inherited - Whether to include members who only\n * have access from a parent shared folder.\n * @property {number} limit - Number of members to return max per query.\n * Defaults to 100 if no limit is specified.\n */\n\n/**\n * Arguments for list_file_members/batch.\n * @typedef {Object} SharingListFileMembersBatchArg\n * @property {Array.<Object>} files - Files for which to return members.\n * @property {number} limit - Number of members to return max per query.\n * Defaults to 10 if no limit is specified.\n */\n\n/**\n * Per-file result for list_file_members/batch.\n * @typedef {Object} SharingListFileMembersBatchResult\n * @property {string} file - This is the input file identifier, whether an ID or\n * a path.\n * @property {SharingListFileMembersIndividualResult} result - The result for\n * this particular file.\n */\n\n/**\n * Arguments for list_file_members/continue.\n * @typedef {Object} SharingListFileMembersContinueArg\n * @property {string} cursor - The cursor returned by your last call to\n * list_file_members, list_file_members/continue, or list_file_members/batch.\n */\n\n/**\n * Error for list_file_members/continue.\n * @typedef {Object} SharingListFileMembersContinueError\n * @property {SharingSharingUserError} [user_error] - Available if .tag is\n * user_error.\n * @property {SharingSharingFileAccessError} [access_error] - Available if .tag\n * is access_error.\n * @property {('user_error'|'access_error'|'invalid_cursor'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} SharingListFileMembersCountResult\n * @property {SharingSharedFileMembers} members - A list of members on this\n * file.\n * @property {number} member_count - The number of members on this file. This\n * does not include inherited members.\n */\n\n/**\n * Error for list_file_members.\n * @typedef {Object} SharingListFileMembersError\n * @property {SharingSharingUserError} [user_error] - Available if .tag is\n * user_error.\n * @property {SharingSharingFileAccessError} [access_error] - Available if .tag\n * is access_error.\n * @property {('user_error'|'access_error'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} SharingListFileMembersIndividualResult\n * @property {SharingListFileMembersCountResult} [result] - Available if .tag is\n * result. The results of the query for this file if it was successful.\n * @property {SharingSharingFileAccessError} [access_error] - Available if .tag\n * is access_error. The result of the query for this file if it was an error.\n * @property {('result'|'access_error'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * Arguments for list_received_files.\n * @typedef {Object} SharingListFilesArg\n * @property {number} limit - Number of files to return max per query. Defaults\n * to 100 if no limit is specified.\n * @property {Array.<SharingFileAction>} [actions] - File actions to query.\n */\n\n/**\n * Arguments for list_received_files/continue.\n * @typedef {Object} SharingListFilesContinueArg\n * @property {string} cursor - Cursor in ListFilesResult.cursor.\n */\n\n/**\n * Error results for list_received_files/continue.\n * @typedef {Object} SharingListFilesContinueError\n * @property {SharingSharingUserError} [user_error] - Available if .tag is\n * user_error. User account had a problem.\n * @property {('user_error'|'invalid_cursor'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * Success results for list_received_files.\n * @typedef {Object} SharingListFilesResult\n * @property {Array.<SharingSharedFileMetadata>} entries - Information about the\n * files shared with current user.\n * @property {string} [cursor] - Cursor used to obtain additional shared files.\n */\n\n/**\n * @typedef {Object} SharingListFolderMembersArgs\n * @property {string} shared_folder_id - The ID for the shared folder.\n * @property {Array.<SharingMemberAction>} [actions] - This is a list indicating\n * whether each returned member will include a boolean value\n * MemberPermission.allow that describes whether the current user can perform\n * the MemberAction on the member.\n * @property {number} limit - The maximum number of results that include\n * members, groups and invitees to return per request.\n */\n\n/**\n * @typedef {Object} SharingListFolderMembersContinueArg\n * @property {string} cursor - The cursor returned by your last call to\n * list_folder_members or list_folder_members/continue.\n */\n\n/**\n * @typedef {Object} SharingListFolderMembersContinueError\n * @property {SharingSharedFolderAccessError} [access_error] - Available if .tag\n * is access_error.\n * @property {('access_error'|'invalid_cursor'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} SharingListFolderMembersCursorArg\n * @property {Array.<SharingMemberAction>} [actions] - This is a list indicating\n * whether each returned member will include a boolean value\n * MemberPermission.allow that describes whether the current user can perform\n * the MemberAction on the member.\n * @property {number} limit - The maximum number of results that include\n * members, groups and invitees to return per request.\n */\n\n/**\n * @typedef {Object} SharingListFoldersArgs\n * @property {number} limit - The maximum number of results to return per\n * request.\n * @property {Array.<SharingFolderAction>} [actions] - This is a list indicating\n * whether each returned folder data entry will include a boolean field\n * FolderPermission.allow that describes whether the current user can perform\n * the `FolderAction` on the folder.\n */\n\n/**\n * @typedef {Object} SharingListFoldersContinueArg\n * @property {string} cursor - The cursor returned by the previous API call\n * specified in the endpoint description.\n */\n\n/**\n * @typedef {Object} SharingListFoldersContinueError\n * @property {('invalid_cursor'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * Result for list_folders or list_mountable_folders, depending on which\n * endpoint was requested. Unmounted shared folders can be identified by the\n * absence of SharedFolderMetadata.path_lower.\n * @typedef {Object} SharingListFoldersResult\n * @property {Array.<SharingSharedFolderMetadata>} entries - List of all shared\n * folders the authenticated user has access to.\n * @property {string} [cursor] - Present if there are additional shared folders\n * that have not been returned yet. Pass the cursor into the corresponding\n * continue endpoint (either list_folders/continue or\n * list_mountable_folders/continue) to list additional folders.\n */\n\n/**\n * @typedef {Object} SharingListSharedLinksArg\n * @property {string} [path] - See list_shared_links description.\n * @property {string} [cursor] - The cursor returned by your last call to\n * list_shared_links.\n * @property {boolean} [direct_only] - See list_shared_links description.\n */\n\n/**\n * @typedef {Object} SharingListSharedLinksError\n * @property {FilesLookupError} [path] - Available if .tag is path.\n * @property {('path'|'reset'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} SharingListSharedLinksResult\n * @property\n * {Array.<(SharingFileLinkMetadata|SharingFolderLinkMetadata|SharingSharedLinkMetadata)>}\n * links - Shared links applicable to the path argument.\n * @property {boolean} has_more - Is true if there are additional shared links\n * that have not been returned yet. Pass the cursor into list_shared_links to\n * retrieve them.\n * @property {string} [cursor] - Pass the cursor into list_shared_links to\n * obtain the additional links. Cursor is returned only if no path is given.\n */\n\n/**\n * Contains information about a member's access level to content after an\n * operation.\n * @typedef {Object} SharingMemberAccessLevelResult\n * @property {SharingAccessLevel} [access_level] - The member still has this\n * level of access to the content through a parent folder.\n * @property {string} [warning] - A localized string with additional information\n * about why the user has this access level to the content.\n * @property {Array.<SharingParentFolderAccessInfo>} [access_details] - The\n * parent folders that a member has access to. The field is present if the user\n * has access to the first parent folder where the member gains access.\n */\n\n/**\n * Actions that may be taken on members of a shared folder.\n * @typedef {Object} SharingMemberAction\n * @property {('leave_a_copy'|'make_editor'|'make_owner'|'make_viewer'|'make_viewer_no_comment'|'remove'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * Whether the user is allowed to take the action on the associated member.\n * @typedef {Object} SharingMemberPermission\n * @property {SharingMemberAction} action - The action that the user may wish to\n * take on the member.\n * @property {boolean} allow - True if the user is allowed to take the action.\n * @property {SharingPermissionDeniedReason} [reason] - The reason why the user\n * is denied the permission. Not present if the action is allowed.\n */\n\n/**\n * Policy governing who can be a member of a shared folder. Only applicable to\n * folders owned by a user on a team.\n * @typedef {Object} SharingMemberPolicy\n * @property {('team'|'anyone'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * Includes different ways to identify a member of a shared folder.\n * @typedef {Object} SharingMemberSelector\n * @property {string} [dropbox_id] - Available if .tag is dropbox_id. Dropbox\n * account, team member, or group ID of member.\n * @property {string} [email] - Available if .tag is email. E-mail address of\n * member.\n * @property {('dropbox_id'|'email'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * The information about a member of the shared content.\n * @typedef {Object} SharingMembershipInfo\n * @property {SharingAccessLevel} access_type - The access type for this member.\n * @property {Array.<SharingMemberPermission>} [permissions] - The permissions\n * that requesting user has on this member. The set of permissions corresponds\n * to the MemberActions in the request.\n * @property {string} [initials] - Suggested name initials for a member.\n * @property {boolean} is_inherited - True if the member has access from a\n * parent folder.\n */\n\n/**\n * @typedef {Object} SharingModifySharedLinkSettingsArgs\n * @property {string} url - URL of the shared link to change its settings\n * @property {SharingSharedLinkSettings} settings - Set of settings for the\n * shared link.\n * @property {boolean} remove_expiration - If set to true, removes the\n * expiration of the shared link.\n */\n\n/**\n * @typedef {Object} SharingModifySharedLinkSettingsError\n * @property {SharingSharedLinkSettingsError} [settings_error] - Available if\n * .tag is settings_error. There is an error with the given settings\n * @property {('shared_link_not_found'|'shared_link_access_denied'|'unsupported_link_type'|'other'|'settings_error'|'email_not_verified')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} SharingMountFolderArg\n * @property {string} shared_folder_id - The ID of the shared folder to mount.\n */\n\n/**\n * @typedef {Object} SharingMountFolderError\n * @property {SharingSharedFolderAccessError} [access_error] - Available if .tag\n * is access_error.\n * @property {SharingInsufficientQuotaAmounts} [insufficient_quota] - Available\n * if .tag is insufficient_quota. The current user does not have enough space to\n * mount the shared folder.\n * @property {('access_error'|'inside_shared_folder'|'insufficient_quota'|'already_mounted'|'no_permission'|'not_mountable'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * Contains information about a parent folder that a member has access to.\n * @typedef {Object} SharingParentFolderAccessInfo\n * @property {string} folder_name - Display name for the folder.\n * @property {string} shared_folder_id - The identifier of the parent shared\n * folder.\n * @property {Array.<SharingMemberPermission>} permissions - The user's\n * permissions for the parent shared folder.\n */\n\n/**\n * Metadata for a path-based shared link.\n * @typedef {Object} SharingPathLinkMetadata\n@property {'path'} [.tag] - Tag identifying this subtype variant. This field is\nonly present when needed to discriminate between multiple possible subtypes.\n * @property {string} url - URL of the shared link.\n * @property {SharingVisibility} visibility - Who can access the link.\n * @property {string} path - Path in user's Dropbox.\n * @property {Timestamp} [expires] - Expiration time, if set. By default the\n * link won't expire.\n */\n\n/**\n * Flag to indicate pending upload default (for linking to not-yet-existing\n * paths).\n * @typedef {Object} SharingPendingUploadMode\n * @property {('file'|'folder')} .tag - Tag identifying the union variant.\n */\n\n/**\n * Possible reasons the user is denied a permission.\n * @typedef {Object} SharingPermissionDeniedReason\n * @property {('user_not_same_team_as_owner'|'user_not_allowed_by_owner'|'target_is_indirect_member'|'target_is_owner'|'target_is_self'|'target_not_active'|'folder_is_limited_team_folder'|'owner_not_on_team'|'permission_denied'|'restricted_by_team'|'user_account_type'|'user_not_on_team'|'folder_is_inside_shared_folder'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} SharingRelinquishFileMembershipArg\n * @property {string} file - The path or id for the file.\n */\n\n/**\n * @typedef {Object} SharingRelinquishFileMembershipError\n * @property {SharingSharingFileAccessError} [access_error] - Available if .tag\n * is access_error.\n * @property {('access_error'|'group_access'|'no_permission'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} SharingRelinquishFolderMembershipArg\n * @property {string} shared_folder_id - The ID for the shared folder.\n * @property {boolean} leave_a_copy - Keep a copy of the folder's contents upon\n * relinquishing membership.\n */\n\n/**\n * @typedef {Object} SharingRelinquishFolderMembershipError\n * @property {SharingSharedFolderAccessError} [access_error] - Available if .tag\n * is access_error.\n * @property {('access_error'|'folder_owner'|'mounted'|'group_access'|'team_folder'|'no_permission'|'no_explicit_access'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * Arguments for remove_file_member_2.\n * @typedef {Object} SharingRemoveFileMemberArg\n * @property {string} file - File from which to remove members.\n * @property {SharingMemberSelector} member - Member to remove from this file.\n * Note that even if an email is specified, it may result in the removal of a\n * user (not an invitee) if the user's main account corresponds to that email\n * address.\n */\n\n/**\n * Errors for remove_file_member_2.\n * @typedef {Object} SharingRemoveFileMemberError\n * @property {SharingSharingUserError} [user_error] - Available if .tag is\n * user_error.\n * @property {SharingSharingFileAccessError} [access_error] - Available if .tag\n * is access_error.\n * @property {SharingMemberAccessLevelResult} [no_explicit_access] - Available\n * if .tag is no_explicit_access. This member does not have explicit access to\n * the file and therefore cannot be removed. The return value is the access that\n * a user might have to the file from a parent folder.\n * @property {('user_error'|'access_error'|'no_explicit_access'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} SharingRemoveFolderMemberArg\n * @property {string} shared_folder_id - The ID for the shared folder.\n * @property {SharingMemberSelector} member - The member to remove from the\n * folder.\n * @property {boolean} leave_a_copy - If true, the removed user will keep their\n * copy of the folder after it's unshared, assuming it was mounted. Otherwise,\n * it will be removed from their Dropbox. Also, this must be set to false when\n * kicking a group.\n */\n\n/**\n * @typedef {Object} SharingRemoveFolderMemberError\n * @property {SharingSharedFolderAccessError} [access_error] - Available if .tag\n * is access_error.\n * @property {SharingSharedFolderMemberError} [member_error] - Available if .tag\n * is member_error.\n * @property {('access_error'|'member_error'|'folder_owner'|'group_access'|'team_folder'|'no_permission'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} SharingRemoveMemberJobStatus\n * @property {SharingMemberAccessLevelResult} [complete] - Available if .tag is\n * complete. Removing the folder member has finished. The value is information\n * about whether the member has another form of access.\n * @property {SharingRemoveFolderMemberError} [failed] - Available if .tag is\n * failed.\n * @property {('in_progress'|'complete'|'failed')} .tag - Tag identifying the union variant.\n */\n\n/**\n * The access permission that can be requested by the caller for the shared\n * link. Note that the final resolved visibility of the shared link takes into\n * account other aspects, such as team and shared folder settings. Check the\n * ResolvedVisibility for more info on the possible resolved visibility values\n * of shared links.\n * @typedef {Object} SharingRequestedVisibility\n * @property {('public'|'team_only'|'password')} .tag - Tag identifying the union variant.\n */\n\n/**\n * The actual access permissions values of shared links after taking into\n * account user preferences and the team and shared folder settings. Check the\n * RequestedVisibility for more info on the possible visibility values that can\n * be set by the shared link's owner.\n * @typedef {Object} SharingResolvedVisibility\n * @property {('public'|'team_only'|'password'|'team_and_password'|'shared_folder_only'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} SharingRevokeSharedLinkArg\n * @property {string} url - URL of the shared link.\n */\n\n/**\n * @typedef {Object} SharingRevokeSharedLinkError\n * @property {('shared_link_not_found'|'shared_link_access_denied'|'unsupported_link_type'|'other'|'shared_link_malformed')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} SharingShareFolderArg\n * @property {string} path - The path to the folder to share. If it does not\n * exist, then a new one is created.\n * @property {SharingMemberPolicy} [member_policy] - Who can be a member of this\n * shared folder. Only applicable if the current user is on a team.\n * @property {SharingAclUpdatePolicy} [acl_update_policy] - Who can add and\n * remove members of this shared folder.\n * @property {SharingSharedLinkPolicy} [shared_link_policy] - The policy to\n * apply to shared links created for content inside this shared folder.  The\n * current user must be on a team to set this policy to\n * SharedLinkPolicy.members.\n * @property {boolean} force_async - Whether to force the share to happen\n * asynchronously.\n * @property {Array.<SharingFolderAction>} [actions] - This is a list indicating\n * whether each returned folder data entry will include a boolean field\n * FolderPermission.allow that describes whether the current user can perform\n * the `FolderAction` on the folder.\n * @property {SharingLinkSettings} [link_settings] - Settings on the link for\n * this folder.\n * @property {SharingViewerInfoPolicy} [viewer_info_policy] - Who can\n * enable/disable viewer info for this shared folder.\n */\n\n/**\n * @typedef {Object} SharingShareFolderError\n * @property {SharingSharePathError} [bad_path] - Available if .tag is bad_path.\n * :field:`ShareFolderArg.path` is invalid.\n * @property {('email_unverified'|'bad_path'|'team_policy_disallows_member_policy'|'disallowed_shared_link_policy'|'other'|'no_permission')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} SharingShareFolderErrorBase\n * @property {SharingSharePathError} [bad_path] - Available if .tag is bad_path.\n * :field:`ShareFolderArg.path` is invalid.\n * @property {('email_unverified'|'bad_path'|'team_policy_disallows_member_policy'|'disallowed_shared_link_policy'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} SharingShareFolderJobStatus\n * @property {SharingSharedFolderMetadata} [complete] - Available if .tag is\n * complete. The share job has finished. The value is the metadata for the\n * folder.\n * @property {SharingShareFolderError} [failed] - Available if .tag is failed.\n * @property {('in_progress'|'complete'|'failed')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} SharingShareFolderLaunch\n * @property {string} [async_job_id] - Available if .tag is async_job_id. This\n * response indicates that the processing is asynchronous. The string is an id\n * that can be used to obtain the status of the asynchronous job.\n * @property {SharingSharedFolderMetadata} [complete] - Available if .tag is\n * complete.\n * @property {('async_job_id'|'complete')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} SharingSharePathError\n * @property {SharingSharedFolderMetadata} [already_shared] - Available if .tag\n * is already_shared. Folder is already shared. Contains metadata about the\n * existing shared folder.\n * @property {FilesPathRootError} [invalid_path_root] - Available if .tag is\n * invalid_path_root. The path root parameter provided is invalid.\n * @property {('is_file'|'inside_shared_folder'|'contains_shared_folder'|'contains_app_folder'|'contains_team_folder'|'is_app_folder'|'inside_app_folder'|'is_public_folder'|'inside_public_folder'|'already_shared'|'invalid_path'|'is_osx_package'|'inside_osx_package'|'invalid_path_root'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * Metadata of a shared link for a file or folder.\n * @typedef {Object} SharingSharedContentLinkMetadata\n * @property {Array.<SharingLinkAudience>} audience_options - The audience\n * options that are available for the content. Some audience options may be\n * unavailable. For example, team_only may be unavailable if the content is not\n * owned by a user on a team. The 'default' audience option is always available\n * if the user can modify link settings.\n * @property {SharingLinkAudience} current_audience - The current audience of\n * the link.\n * @property {Array.<SharingLinkPermission>} link_permissions - A list of\n * permissions for actions you can perform on the link.\n * @property {boolean} password_protected - Whether the link is protected by a\n * password.\n * @property {string} url - The URL of the link.\n * @property {Timestamp} [expiry] - Whether the link has an expiry set on it. A\n * link with an expiry will have its  audience changed to members when the\n * expiry is reached.\n */\n\n/**\n * @typedef {Object} SharingSharedContentLinkMetadataBase\n * @property {Array.<SharingLinkAudience>} audience_options - The audience\n * options that are available for the content. Some audience options may be\n * unavailable. For example, team_only may be unavailable if the content is not\n * owned by a user on a team. The 'default' audience option is always available\n * if the user can modify link settings.\n * @property {SharingLinkAudience} current_audience - The current audience of\n * the link.\n * @property {Array.<SharingLinkPermission>} link_permissions - A list of\n * permissions for actions you can perform on the link.\n * @property {boolean} password_protected - Whether the link is protected by a\n * password.\n * @property {Timestamp} [expiry] - Whether the link has an expiry set on it. A\n * link with an expiry will have its  audience changed to members when the\n * expiry is reached.\n */\n\n/**\n * Shared file user, group, and invitee membership. Used for the results of\n * list_file_members and list_file_members/continue, and used as part of the\n * results for list_file_members/batch.\n * @typedef {Object} SharingSharedFileMembers\n * @property {Array.<SharingUserMembershipInfo>} users - The list of user\n * members of the shared file.\n * @property {Array.<SharingGroupMembershipInfo>} groups - The list of group\n * members of the shared file.\n * @property {Array.<SharingInviteeMembershipInfo>} invitees - The list of\n * invited members of a file, but have not logged in and claimed this.\n * @property {string} [cursor] - Present if there are additional shared file\n * members that have not been returned yet. Pass the cursor into\n * list_file_members/continue to list additional members.\n */\n\n/**\n * Properties of the shared file.\n * @typedef {Object} SharingSharedFileMetadata\n * @property {SharingFolderPolicy} policy - Policies governing this shared file.\n * @property {string} preview_url - URL for displaying a web preview of the\n * shared file.\n * @property {string} name - The name of this file.\n * @property {string} id - The ID of the file.\n * @property {SharingSharedContentLinkMetadata} [link_metadata] - The metadata\n * of the link associated for the file.\n * @property {Array.<SharingFilePermission>} [permissions] - The sharing\n * permissions that requesting user has on this file. This corresponds to the\n * entries given in GetFileMetadataBatchArg.actions or\n * GetFileMetadataArg.actions.\n * @property {UsersTeam} [owner_team] - The team that owns the file. This field\n * is not present if the file is not owned by a team.\n * @property {string} [parent_shared_folder_id] - The ID of the parent shared\n * folder. This field is present only if the file is contained within a shared\n * folder.\n * @property {string} [path_lower] - The lower-case full path of this file.\n * Absent for unmounted files.\n * @property {string} [path_display] - The cased path to be used for display\n * purposes only. In rare instances the casing will not correctly match the\n * user's filesystem, but this behavior will match the path provided in the Core\n * API v1. Absent for unmounted files.\n * @property {Timestamp} [time_invited] - Timestamp indicating when the current\n * user was invited to this shared file. If the user was not invited to the\n * shared file, the timestamp will indicate when the user was invited to the\n * parent shared folder. This value may be absent.\n */\n\n/**\n * There is an error accessing the shared folder.\n * @typedef {Object} SharingSharedFolderAccessError\n * @property {('invalid_id'|'not_a_member'|'email_unverified'|'unmounted'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} SharingSharedFolderMemberError\n * @property {SharingMemberAccessLevelResult} [no_explicit_access] - Available\n * if .tag is no_explicit_access. The target member only has inherited access to\n * the shared folder.\n * @property {('invalid_dropbox_id'|'not_a_member'|'no_explicit_access'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * Shared folder user and group membership.\n * @typedef {Object} SharingSharedFolderMembers\n * @property {Array.<SharingUserMembershipInfo>} users - The list of user\n * members of the shared folder.\n * @property {Array.<SharingGroupMembershipInfo>} groups - The list of group\n * members of the shared folder.\n * @property {Array.<SharingInviteeMembershipInfo>} invitees - The list of\n * invitees to the shared folder.\n * @property {string} [cursor] - Present if there are additional shared folder\n * members that have not been returned yet. Pass the cursor into\n * list_folder_members/continue to list additional members.\n */\n\n/**\n * The metadata which includes basic information about the shared folder.\n * @typedef {Object} SharingSharedFolderMetadata\n * @property {SharingAccessLevel} access_type - The current user's access level\n * for this shared folder.\n * @property {boolean} is_inside_team_folder - Whether this folder is inside of\n * a team folder.\n * @property {boolean} is_team_folder - Whether this folder is a team folder\n * https://www.dropbox.com/en/help/986.\n * @property {string} name - The name of the this shared folder.\n * @property {SharingFolderPolicy} policy - Policies governing this shared\n * folder.\n * @property {string} preview_url - URL for displaying a web preview of the\n * shared folder.\n * @property {string} shared_folder_id - The ID of the shared folder.\n * @property {Timestamp} time_invited - Timestamp indicating when the current\n * user was invited to this shared folder.\n * @property {UsersTeam} [owner_team] - The team that owns the folder. This\n * field is not present if the folder is not owned by a team.\n * @property {string} [parent_shared_folder_id] - The ID of the parent shared\n * folder. This field is present only if the folder is contained within another\n * shared folder.\n * @property {string} [path_lower] - The lower-cased full path of this shared\n * folder. Absent for unmounted folders.\n * @property {SharingSharedContentLinkMetadata} [link_metadata] - The metadata\n * of the shared content link to this shared folder. Absent if there is no link\n * on the folder.\n * @property {Array.<SharingFolderPermission>} [permissions] - Actions the\n * current user may perform on the folder and its contents. The set of\n * permissions corresponds to the FolderActions in the request.\n */\n\n/**\n * Properties of the shared folder.\n * @typedef {Object} SharingSharedFolderMetadataBase\n * @property {SharingAccessLevel} access_type - The current user's access level\n * for this shared folder.\n * @property {boolean} is_inside_team_folder - Whether this folder is inside of\n * a team folder.\n * @property {boolean} is_team_folder - Whether this folder is a team folder\n * https://www.dropbox.com/en/help/986.\n * @property {UsersTeam} [owner_team] - The team that owns the folder. This\n * field is not present if the folder is not owned by a team.\n * @property {string} [parent_shared_folder_id] - The ID of the parent shared\n * folder. This field is present only if the folder is contained within another\n * shared folder.\n * @property {string} [path_lower] - The lower-cased full path of this shared\n * folder. Absent for unmounted folders.\n */\n\n/**\n * @typedef {Object} SharingSharedLinkAccessFailureReason\n * @property {('login_required'|'email_verify_required'|'password_required'|'team_only'|'owner_only'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} SharingSharedLinkError\n * @property {('shared_link_not_found'|'shared_link_access_denied'|'unsupported_link_type'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * The metadata of a shared link\n * @typedef {Object} SharingSharedLinkMetadata\n@property {(\"file\"|\"folder\")} .tag - Tag identifying the subtype variant.\n * @property {string} url - URL of the shared link.\n * @property {string} name - The linked file name (including extension). This\n * never contains a slash.\n * @property {SharingLinkPermissions} link_permissions - The link's access\n * permissions.\n * @property {string} [id] - A unique identifier for the linked file.\n * @property {Timestamp} [expires] - Expiration time, if set. By default the\n * link won't expire.\n * @property {string} [path_lower] - The lowercased full path in the user's\n * Dropbox. This always starts with a slash. This field will only be present\n * only if the linked file is in the authenticated user's  dropbox.\n * @property {SharingTeamMemberInfo} [team_member_info] - The team membership\n * information of the link's owner.  This field will only be present  if the\n * link's owner is a team member.\n * @property {UsersTeam} [content_owner_team_info] - The team information of the\n * content's owner. This field will only be present if the content's owner is a\n * team member and the content's owner team is different from the link's owner\n * team.\n */\n\n/**\n * Who can view shared links in this folder.\n * @typedef {Object} SharingSharedLinkPolicy\n * @property {('anyone'|'team'|'members'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} SharingSharedLinkSettings\n * @property {SharingRequestedVisibility} [requested_visibility] - The requested\n * access for this shared link.\n * @property {string} [link_password] - If requested_visibility is\n * RequestedVisibility.password this is needed to specify the password to access\n * the link.\n * @property {Timestamp} [expires] - Expiration time of the shared link. By\n * default the link won't expire.\n */\n\n/**\n * @typedef {Object} SharingSharedLinkSettingsError\n * @property {('invalid_settings'|'not_authorized')} .tag - Tag identifying the union variant.\n */\n\n/**\n * User could not access this file.\n * @typedef {Object} SharingSharingFileAccessError\n * @property {('no_permission'|'invalid_file'|'is_folder'|'inside_public_folder'|'inside_osx_package'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * User account had a problem preventing this action.\n * @typedef {Object} SharingSharingUserError\n * @property {('email_unverified'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * Information about a team member.\n * @typedef {Object} SharingTeamMemberInfo\n * @property {UsersTeam} team_info - Information about the member's team\n * @property {string} display_name - The display name of the user.\n * @property {string} [member_id] - ID of user as a member of a team. This field\n * will only be present if the member is in the same team as current user.\n */\n\n/**\n * @typedef {Object} SharingTransferFolderArg\n * @property {string} shared_folder_id - The ID for the shared folder.\n * @property {string} to_dropbox_id - A account or team member ID to transfer\n * ownership to.\n */\n\n/**\n * @typedef {Object} SharingTransferFolderError\n * @property {SharingSharedFolderAccessError} [access_error] - Available if .tag\n * is access_error.\n * @property {('access_error'|'invalid_dropbox_id'|'new_owner_not_a_member'|'new_owner_unmounted'|'new_owner_email_unverified'|'team_folder'|'no_permission'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} SharingUnmountFolderArg\n * @property {string} shared_folder_id - The ID for the shared folder.\n */\n\n/**\n * @typedef {Object} SharingUnmountFolderError\n * @property {SharingSharedFolderAccessError} [access_error] - Available if .tag\n * is access_error.\n * @property {('access_error'|'no_permission'|'not_unmountable'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * Arguments for unshare_file.\n * @typedef {Object} SharingUnshareFileArg\n * @property {string} file - The file to unshare.\n */\n\n/**\n * Error result for unshare_file.\n * @typedef {Object} SharingUnshareFileError\n * @property {SharingSharingUserError} [user_error] - Available if .tag is\n * user_error.\n * @property {SharingSharingFileAccessError} [access_error] - Available if .tag\n * is access_error.\n * @property {('user_error'|'access_error'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} SharingUnshareFolderArg\n * @property {string} shared_folder_id - The ID for the shared folder.\n * @property {boolean} leave_a_copy - If true, members of this shared folder\n * will get a copy of this folder after it's unshared. Otherwise, it will be\n * removed from their Dropbox. The current user, who is an owner, will always\n * retain their copy.\n */\n\n/**\n * @typedef {Object} SharingUnshareFolderError\n * @property {SharingSharedFolderAccessError} [access_error] - Available if .tag\n * is access_error.\n * @property {('access_error'|'team_folder'|'no_permission'|'too_many_files'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * Arguments for update_file_member.\n * @typedef {Object} SharingUpdateFileMemberArgs\n * @property {string} file - File for which we are changing a member's access.\n * @property {SharingMemberSelector} member - The member whose access we are\n * changing.\n * @property {SharingAccessLevel} access_level - The new access level for the\n * member.\n */\n\n/**\n * @typedef {Object} SharingUpdateFolderMemberArg\n * @property {string} shared_folder_id - The ID for the shared folder.\n * @property {SharingMemberSelector} member - The member of the shared folder to\n * update.  Only the MemberSelector.dropbox_id may be set at this time.\n * @property {SharingAccessLevel} access_level - The new access level for\n * member. AccessLevel.owner is disallowed.\n */\n\n/**\n * @typedef {Object} SharingUpdateFolderMemberError\n * @property {SharingSharedFolderAccessError} [access_error] - Available if .tag\n * is access_error.\n * @property {SharingSharedFolderMemberError} [member_error] - Available if .tag\n * is member_error.\n * @property {SharingAddFolderMemberError} [no_explicit_access] - Available if\n * .tag is no_explicit_access. If updating the access type required the member\n * to be added to the shared folder and there was an error when adding the\n * member.\n * @property {('access_error'|'member_error'|'no_explicit_access'|'insufficient_plan'|'no_permission'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * If any of the policies are unset, then they retain their current setting.\n * @typedef {Object} SharingUpdateFolderPolicyArg\n * @property {string} shared_folder_id - The ID for the shared folder.\n * @property {SharingMemberPolicy} [member_policy] - Who can be a member of this\n * shared folder. Only applicable if the current user is on a team.\n * @property {SharingAclUpdatePolicy} [acl_update_policy] - Who can add and\n * remove members of this shared folder.\n * @property {SharingViewerInfoPolicy} [viewer_info_policy] - Who can\n * enable/disable viewer info for this shared folder.\n * @property {SharingSharedLinkPolicy} [shared_link_policy] - The policy to\n * apply to shared links created for content inside this shared folder. The\n * current user must be on a team to set this policy to\n * SharedLinkPolicy.members.\n * @property {SharingLinkSettings} [link_settings] - Settings on the link for\n * this folder.\n */\n\n/**\n * @typedef {Object} SharingUpdateFolderPolicyError\n * @property {SharingSharedFolderAccessError} [access_error] - Available if .tag\n * is access_error.\n * @property {('access_error'|'not_on_team'|'team_policy_disallows_member_policy'|'disallowed_shared_link_policy'|'no_permission'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * Basic information about a user. Use users.get_account and\n * users.get_account_batch to obtain more detailed information.\n * @typedef {Object} SharingUserInfo\n * @property {string} account_id - The account ID of the user.\n * @property {boolean} same_team - If the user is in the same team as current\n * user.\n * @property {string} [team_member_id] - The team member ID of the shared folder\n * member. Only present if same_team is true.\n */\n\n/**\n * The information about a user member of the shared content.\n * @typedef {Object} SharingUserMembershipInfo\n * @property {SharingAccessLevel} access_type - The access type for this member.\n * @property {SharingUserInfo} user - The account information for the membership\n * user.\n * @property {Array.<SharingMemberPermission>} [permissions] - The permissions\n * that requesting user has on this member. The set of permissions corresponds\n * to the MemberActions in the request.\n * @property {string} [initials] - Suggested name initials for a member.\n * @property {boolean} is_inherited - True if the member has access from a\n * parent folder.\n */\n\n/**\n * @typedef {Object} SharingViewerInfoPolicy\n * @property {('enabled'|'disabled'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * Who can access a shared link. The most open visibility is public. The default\n * depends on many aspects, such as team and user preferences and shared folder\n * settings.\n * @typedef {Object} SharingVisibility\n * @property {('public'|'team_only'|'password'|'team_and_password'|'shared_folder_only'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * Information on active web sessions\n * @typedef {Object} TeamActiveWebSession\n * @property {string} session_id - The session id\n * @property {string} user_agent - Information on the hosting device\n * @property {string} os - Information on the hosting operating system\n * @property {string} browser - Information on the browser used for this web\n * session\n * @property {string} [ip_address] - The IP address of the last activity from\n * this session\n * @property {string} [country] - The country from which the last activity from\n * this session was made\n * @property {Timestamp} [created] - The time this session was created\n * @property {Timestamp} [updated] - The time of the last activity from this\n * session\n */\n\n/**\n * Arguments for adding property templates.\n * @typedef {Object} TeamAddPropertyTemplateArg\n * @property {string} name - A display name for the property template. Property\n * template names can be up to 256 bytes.\n * @property {string} description - Description for new property template.\n * Property template descriptions can be up to 1024 bytes.\n * @property {Array.<PropertiesPropertyFieldTemplate>} fields - This is a list\n * of custom properties associated with a property template. There can be up to\n * 64 properties in a single property template.\n */\n\n/**\n * @typedef {Object} TeamAddPropertyTemplateResult\n * @property {string} template_id - An identifier for property template added by\n * properties/template/add.\n */\n\n/**\n * Describes which team-related admin permissions a user has.\n * @typedef {Object} TeamAdminTier\n * @property {('team_admin'|'user_management_admin'|'support_admin'|'member_only')} .tag - Tag identifying the union variant.\n */\n\n/**\n * Information on linked third party applications\n * @typedef {Object} TeamApiApp\n * @property {string} app_id - The application unique id\n * @property {string} app_name - The application name\n * @property {boolean} is_app_folder - Whether the linked application uses a\n * dedicated folder\n * @property {string} [publisher] - The application publisher name\n * @property {string} [publisher_url] - The publisher's URL\n * @property {Timestamp} [linked] - The time this application was linked\n */\n\n/**\n * Base report structure.\n * @typedef {Object} TeamBaseDfbReport\n * @property {string} start_date - First date present in the results as\n * 'YYYY-MM-DD' or None.\n */\n\n/**\n * Base error that all errors for existing team folders should extend.\n * @typedef {Object} TeamBaseTeamFolderError\n * @property {TeamTeamFolderAccessError} [access_error] - Available if .tag is\n * access_error.\n * @property {TeamTeamFolderInvalidStatusError} [status_error] - Available if\n * .tag is status_error.\n * @property {('access_error'|'status_error'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * Input arguments that can be provided for most reports.\n * @typedef {Object} TeamDateRange\n * @property {Timestamp} [start_date] - Optional starting date (inclusive)\n * @property {Timestamp} [end_date] - Optional ending date (exclusive)\n */\n\n/**\n * Errors that can originate from problems in input arguments to reports.\n * @typedef {Object} TeamDateRangeError\n * @property {'other'} .tag - Tag identifying the union variant.\n */\n\n/**\n * Information about linked Dropbox desktop client sessions\n * @typedef {Object} TeamDesktopClientSession\n * @property {string} session_id - The session id\n * @property {string} host_name - Name of the hosting desktop\n * @property {TeamDesktopPlatform} client_type - The Dropbox desktop client type\n * @property {string} client_version - The Dropbox client version\n * @property {string} platform - Information on the hosting platform\n * @property {boolean} is_delete_on_unlink_supported - Whether it's possible to\n * delete all of the account files upon unlinking\n * @property {string} [ip_address] - The IP address of the last activity from\n * this session\n * @property {string} [country] - The country from which the last activity from\n * this session was made\n * @property {Timestamp} [created] - The time this session was created\n * @property {Timestamp} [updated] - The time of the last activity from this\n * session\n */\n\n/**\n * @typedef {Object} TeamDesktopPlatform\n * @property {('windows'|'mac'|'linux'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} TeamDeviceSession\n * @property {string} session_id - The session id\n * @property {string} [ip_address] - The IP address of the last activity from\n * this session\n * @property {string} [country] - The country from which the last activity from\n * this session was made\n * @property {Timestamp} [created] - The time this session was created\n * @property {Timestamp} [updated] - The time of the last activity from this\n * session\n */\n\n/**\n * @typedef {Object} TeamDeviceSessionArg\n * @property {string} session_id - The session id\n * @property {string} team_member_id - The unique id of the member owning the\n * device\n */\n\n/**\n * Each of the items is an array of values, one value per day. The value is the\n * number of devices active within a time window, ending with that day. If there\n * is no data for a day, then the value will be None.\n * @typedef {Object} TeamDevicesActive\n * @property {Array.<Object>} windows - Array of number of linked windows\n * (desktop) clients with activity.\n * @property {Array.<Object>} macos - Array of number of linked mac (desktop)\n * clients with activity.\n * @property {Array.<Object>} linux - Array of number of linked linus (desktop)\n * clients with activity.\n * @property {Array.<Object>} ios - Array of number of linked ios devices with\n * activity.\n * @property {Array.<Object>} android - Array of number of linked android\n * devices with activity.\n * @property {Array.<Object>} other - Array of number of other linked devices\n * (blackberry, windows phone, etc)  with activity.\n * @property {Array.<Object>} total - Array of total number of linked clients\n * with activity.\n */\n\n/**\n * Activity Report Result. Each of the items in the storage report is an array\n * of values, one value per day. If there is no data for a day, then the value\n * will be None.\n * @typedef {Object} TeamGetActivityReport\n * @property {string} start_date - First date present in the results as\n * 'YYYY-MM-DD' or None.\n * @property {Array.<Object>} adds - Array of total number of adds by team\n * members.\n * @property {Array.<Object>} edits - Array of number of edits by team members.\n * If the same user edits the same file multiple times this is counted as a\n * single edit.\n * @property {Array.<Object>} deletes - Array of total number of deletes by team\n * members.\n * @property {Array.<Object>} active_users_28_day - Array of the number of users\n * who have been active in the last 28 days.\n * @property {Array.<Object>} active_users_7_day - Array of the number of users\n * who have been active in the last week.\n * @property {Array.<Object>} active_users_1_day - Array of the number of users\n * who have been active in the last day.\n * @property {Array.<Object>} active_shared_folders_28_day - Array of the number\n * of shared folders with some activity in the last 28 days.\n * @property {Array.<Object>} active_shared_folders_7_day - Array of the number\n * of shared folders with some activity in the last week.\n * @property {Array.<Object>} active_shared_folders_1_day - Array of the number\n * of shared folders with some activity in the last day.\n * @property {Array.<Object>} shared_links_created - Array of the number of\n * shared links created.\n * @property {Array.<Object>} shared_links_viewed_by_team - Array of the number\n * of views by team users to shared links created by the team.\n * @property {Array.<Object>} shared_links_viewed_by_outside_user - Array of the\n * number of views by users outside of the team to shared links created by the\n * team.\n * @property {Array.<Object>} shared_links_viewed_by_not_logged_in - Array of\n * the number of views by non-logged-in users to shared links created by the\n * team.\n * @property {Array.<Object>} shared_links_viewed_total - Array of the total\n * number of views to shared links created by the team.\n */\n\n/**\n * Devices Report Result. Contains subsections for different time ranges of\n * activity. Each of the items in each subsection of the storage report is an\n * array of values, one value per day. If there is no data for a day, then the\n * value will be None.\n * @typedef {Object} TeamGetDevicesReport\n * @property {string} start_date - First date present in the results as\n * 'YYYY-MM-DD' or None.\n * @property {TeamDevicesActive} active_1_day - Report of the number of devices\n * active in the last day.\n * @property {TeamDevicesActive} active_7_day - Report of the number of devices\n * active in the last 7 days.\n * @property {TeamDevicesActive} active_28_day - Report of the number of devices\n * active in the last 28 days.\n */\n\n/**\n * Membership Report Result. Each of the items in the storage report is an array\n * of values, one value per day. If there is no data for a day, then the value\n * will be None.\n * @typedef {Object} TeamGetMembershipReport\n * @property {string} start_date - First date present in the results as\n * 'YYYY-MM-DD' or None.\n * @property {Array.<Object>} team_size - Team size, for each day.\n * @property {Array.<Object>} pending_invites - The number of pending invites to\n * the team, for each day.\n * @property {Array.<Object>} members_joined - The number of members that joined\n * the team, for each day.\n * @property {Array.<Object>} suspended_members - The number of suspended team\n * members, for each day.\n * @property {Array.<Object>} licenses - The total number of licenses the team\n * has, for each day.\n */\n\n/**\n * Storage Report Result. Each of the items in the storage report is an array of\n * values, one value per day. If there is no data for a day, then the value will\n * be None.\n * @typedef {Object} TeamGetStorageReport\n * @property {string} start_date - First date present in the results as\n * 'YYYY-MM-DD' or None.\n * @property {Array.<Object>} total_usage - Sum of the shared, unshared, and\n * datastore usages, for each day.\n * @property {Array.<Object>} shared_usage - Array of the combined size (bytes)\n * of team members' shared folders, for each day.\n * @property {Array.<Object>} unshared_usage - Array of the combined size\n * (bytes) of team members' root namespaces, for each day.\n * @property {Array.<Object>} shared_folders - Array of the number of shared\n * folders owned by team members, for each day.\n * @property {Array.<Array.<TeamStorageBucket>>} member_storage_map - Array of\n * storage summaries of team members' account sizes. Each storage summary is an\n * array of key, value pairs, where each pair describes a storage bucket. The\n * key indicates the upper bound of the bucket and the value is the number of\n * users in that bucket. There is one such summary per day. If there is no data\n * for a day, the storage summary will be empty.\n */\n\n/**\n * Role of a user in group.\n * @typedef {Object} TeamGroupAccessType\n * @property {('member'|'owner')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} TeamGroupCreateArg\n * @property {string} group_name - Group name.\n * @property {string} [group_external_id] - The creator of a team can associate\n * an arbitrary external ID to the group.\n * @property {TeamCommonGroupManagementType} [group_management_type] - Whether\n * the team can be managed by selected users, or only by team admins.\n */\n\n/**\n * @typedef {Object} TeamGroupCreateError\n * @property {('group_name_already_used'|'group_name_invalid'|'external_id_already_in_use'|'system_managed_group_disallowed'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} TeamGroupDeleteError\n * @property {('group_not_found'|'other'|'system_managed_group_disallowed'|'group_already_deleted')} .tag - Tag identifying the union variant.\n */\n\n/**\n * Full description of a group.\n * @typedef {Object} TeamGroupFullInfo\n * @property {string} group_name\n * @property {string} group_id\n * @property {TeamCommonGroupManagementType} group_management_type - Who is\n * allowed to manage the group.\n * @property {number} created - The group creation time as a UTC timestamp in\n * milliseconds since the Unix epoch.\n * @property {string} [group_external_id] - External ID of group. This is an\n * arbitrary ID that an admin can attach to a group.\n * @property {number} [member_count] - The number of members in the group.\n * @property {Array.<TeamGroupMemberInfo>} [members] - List of group members.\n */\n\n/**\n * Profile of group member, and role in group.\n * @typedef {Object} TeamGroupMemberInfo\n * @property {TeamMemberProfile} profile - Profile of group member.\n * @property {TeamGroupAccessType} access_type - The role that the user has in\n * the group.\n */\n\n/**\n * Argument for selecting a group and a single user.\n * @typedef {Object} TeamGroupMemberSelector\n * @property {TeamGroupSelector} group - Specify a group.\n * @property {TeamUserSelectorArg} user - Identity of a user that is a member of\n * group.\n */\n\n/**\n * Error that can be raised when GroupMemberSelector is used, and the user is\n * required to be a member of the specified group.\n * @typedef {Object} TeamGroupMemberSelectorError\n * @property {('group_not_found'|'other'|'system_managed_group_disallowed'|'member_not_in_group')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} TeamGroupMemberSetAccessTypeError\n * @property {('group_not_found'|'other'|'system_managed_group_disallowed'|'member_not_in_group'|'user_cannot_be_manager_of_company_managed_group')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} TeamGroupMembersAddArg\n * @property {TeamGroupSelector} group - Group to which users will be added.\n * @property {Array.<TeamMemberAccess>} members - List of users to be added to\n * the group.\n * @property {boolean} return_members - Whether to return the list of members in\n * the group.  Note that the default value will cause all the group members  to\n * be returned in the response. This may take a long time for large groups.\n */\n\n/**\n * @typedef {Object} TeamGroupMembersAddError\n * @property {Array.<string>} [members_not_in_team] - Available if .tag is\n * members_not_in_team. These members are not part of your team. Currently, you\n * cannot add members to a group if they are not part of your team, though this\n * may change in a subsequent version. To add new members to your Dropbox\n * Business team, use the :route:`members/add` endpoint.\n * @property {Array.<string>} [users_not_found] - Available if .tag is\n * users_not_found. These users were not found in Dropbox.\n * @property {Array.<string>} [user_cannot_be_manager_of_company_managed_group]\n * - Available if .tag is user_cannot_be_manager_of_company_managed_group. A\n * company-managed group cannot be managed by a user.\n * @property {('group_not_found'|'other'|'system_managed_group_disallowed'|'duplicate_user'|'group_not_in_team'|'members_not_in_team'|'users_not_found'|'user_must_be_active_to_be_owner'|'user_cannot_be_manager_of_company_managed_group')} .tag - Tag identifying the union variant.\n */\n\n/**\n * Result returned by groups/members/add and groups/members/remove.\n * @typedef {Object} TeamGroupMembersChangeResult\n * @property {TeamGroupFullInfo} group_info - The group info after member change\n * operation has been performed.\n * @property {string} async_job_id - An ID that can be used to obtain the status\n * of granting/revoking group-owned resources.\n */\n\n/**\n * @typedef {Object} TeamGroupMembersRemoveArg\n * @property {TeamGroupSelector} group - Group from which users will be removed.\n * @property {Array.<TeamUserSelectorArg>} users - List of users to be removed\n * from the group.\n * @property {boolean} return_members - Whether to return the list of members in\n * the group.  Note that the default value will cause all the group members  to\n * be returned in the response. This may take a long time for large groups.\n */\n\n/**\n * @typedef {Object} TeamGroupMembersRemoveError\n * @property {Array.<string>} [members_not_in_team] - Available if .tag is\n * members_not_in_team. These members are not part of your team.\n * @property {Array.<string>} [users_not_found] - Available if .tag is\n * users_not_found. These users were not found in Dropbox.\n * @property {('group_not_found'|'other'|'system_managed_group_disallowed'|'member_not_in_group'|'group_not_in_team'|'members_not_in_team'|'users_not_found')} .tag - Tag identifying the union variant.\n */\n\n/**\n * Argument for selecting a group and a list of users.\n * @typedef {Object} TeamGroupMembersSelector\n * @property {TeamGroupSelector} group - Specify a group.\n * @property {TeamUsersSelectorArg} users - A list of users that are members of\n * group.\n */\n\n/**\n * Error that can be raised when GroupMembersSelector is used, and the users are\n * required to be members of the specified group.\n * @typedef {Object} TeamGroupMembersSelectorError\n * @property {('group_not_found'|'other'|'system_managed_group_disallowed'|'member_not_in_group')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} TeamGroupMembersSetAccessTypeArg\n * @property {TeamGroupSelector} group - Specify a group.\n * @property {TeamUserSelectorArg} user - Identity of a user that is a member of\n * group.\n * @property {TeamGroupAccessType} access_type - New group access type the user\n * will have.\n * @property {boolean} return_members - Whether to return the list of members in\n * the group.  Note that the default value will cause all the group members  to\n * be returned in the response. This may take a long time for large groups.\n */\n\n/**\n * Argument for selecting a single group, either by group_id or by external\n * group ID.\n * @typedef {Object} TeamGroupSelector\n * @property {string} [group_id] - Available if .tag is group_id. Group ID.\n * @property {string} [group_external_id] - Available if .tag is\n * group_external_id. External ID of the group.\n * @property {('group_id'|'group_external_id')} .tag - Tag identifying the union variant.\n */\n\n/**\n * Error that can be raised when GroupSelector is used.\n * @typedef {Object} TeamGroupSelectorError\n * @property {('group_not_found'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * Error that can be raised when GroupSelector is used and team groups are\n * disallowed from being used.\n * @typedef {Object} TeamGroupSelectorWithTeamGroupError\n * @property {('group_not_found'|'other'|'system_managed_group_disallowed')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} TeamGroupUpdateArgs\n * @property {TeamGroupSelector} group - Specify a group.\n * @property {boolean} return_members - Whether to return the list of members in\n * the group.  Note that the default value will cause all the group members  to\n * be returned in the response. This may take a long time for large groups.\n * @property {string} [new_group_name] - Optional argument. Set group name to\n * this if provided.\n * @property {string} [new_group_external_id] - Optional argument. New group\n * external ID. If the argument is None, the group's external_id won't be\n * updated. If the argument is empty string, the group's external id will be\n * cleared.\n * @property {TeamCommonGroupManagementType} [new_group_management_type] - Set\n * new group management type, if provided.\n */\n\n/**\n * @typedef {Object} TeamGroupUpdateError\n * @property {('group_not_found'|'other'|'system_managed_group_disallowed'|'group_name_already_used'|'group_name_invalid'|'external_id_already_in_use')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} TeamGroupsGetInfoError\n * @property {('group_not_on_team'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} TeamGroupsGetInfoItem\n * @property {string} [id_not_found] - Available if .tag is id_not_found. An ID\n * that was provided as a parameter to :route:`groups/get_info`, and did not\n * match a corresponding group. The ID can be a group ID, or an external ID,\n * depending on how the method was called.\n * @property {TeamGroupFullInfo} [group_info] - Available if .tag is group_info.\n * Info about a group.\n * @property {('id_not_found'|'group_info')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} TeamGroupsListArg\n * @property {number} limit - Number of results to return per call.\n */\n\n/**\n * @typedef {Object} TeamGroupsListContinueArg\n * @property {string} cursor - Indicates from what point to get the next set of\n * groups.\n */\n\n/**\n * @typedef {Object} TeamGroupsListContinueError\n * @property {('invalid_cursor'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} TeamGroupsListResult\n * @property {Array.<TeamCommonGroupSummary>} groups\n * @property {string} cursor - Pass the cursor into groups/list/continue to\n * obtain the additional groups.\n * @property {boolean} has_more - Is true if there are additional groups that\n * have not been returned yet. An additional call to groups/list/continue can\n * retrieve them.\n */\n\n/**\n * @typedef {Object} TeamGroupsMembersListArg\n * @property {TeamGroupSelector} group - The group whose members are to be\n * listed.\n * @property {number} limit - Number of results to return per call.\n */\n\n/**\n * @typedef {Object} TeamGroupsMembersListContinueArg\n * @property {string} cursor - Indicates from what point to get the next set of\n * groups.\n */\n\n/**\n * @typedef {Object} TeamGroupsMembersListContinueError\n * @property {('invalid_cursor'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} TeamGroupsMembersListResult\n * @property {Array.<TeamGroupMemberInfo>} members\n * @property {string} cursor - Pass the cursor into groups/members/list/continue\n * to obtain additional group members.\n * @property {boolean} has_more - Is true if there are additional group members\n * that have not been returned yet. An additional call to\n * groups/members/list/continue can retrieve them.\n */\n\n/**\n * @typedef {Object} TeamGroupsPollError\n * @property {('invalid_async_job_id'|'internal_error'|'other'|'access_denied')} .tag - Tag identifying the union variant.\n */\n\n/**\n * Argument for selecting a list of groups, either by group_ids, or external\n * group IDs.\n * @typedef {Object} TeamGroupsSelector\n * @property {Array.<Object>} [group_ids] - Available if .tag is group_ids. List\n * of group IDs.\n * @property {Array.<string>} [group_external_ids] - Available if .tag is\n * group_external_ids. List of external IDs of groups.\n * @property {('group_ids'|'group_external_ids')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} TeamIncludeMembersArg\n * @property {boolean} return_members - Whether to return the list of members in\n * the group.  Note that the default value will cause all the group members  to\n * be returned in the response. This may take a long time for large groups.\n */\n\n/**\n * @typedef {Object} TeamListMemberAppsArg\n * @property {string} team_member_id - The team member id\n */\n\n/**\n * Error returned by linked_apps/list_member_linked_apps.\n * @typedef {Object} TeamListMemberAppsError\n * @property {('member_not_found'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} TeamListMemberAppsResult\n * @property {Array.<TeamApiApp>} linked_api_apps - List of third party\n * applications linked by this team member\n */\n\n/**\n * @typedef {Object} TeamListMemberDevicesArg\n * @property {string} team_member_id - The team's member id\n * @property {boolean} include_web_sessions - Whether to list web sessions of\n * the team's member\n * @property {boolean} include_desktop_clients - Whether to list linked desktop\n * devices of the team's member\n * @property {boolean} include_mobile_clients - Whether to list linked mobile\n * devices of the team's member\n */\n\n/**\n * @typedef {Object} TeamListMemberDevicesError\n * @property {('member_not_found'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} TeamListMemberDevicesResult\n * @property {Array.<TeamActiveWebSession>} [active_web_sessions] - List of web\n * sessions made by this team member\n * @property {Array.<TeamDesktopClientSession>} [desktop_client_sessions] - List\n * of desktop clients used by this team member\n * @property {Array.<TeamMobileClientSession>} [mobile_client_sessions] - List\n * of mobile client used by this team member\n */\n\n/**\n * Arguments for linked_apps/list_members_linked_apps.\n * @typedef {Object} TeamListMembersAppsArg\n * @property {string} [cursor] - At the first call to the\n * linked_apps/list_members_linked_apps the cursor shouldn't be passed. Then, if\n * the result of the call includes a cursor, the following requests should\n * include the received cursors in order to receive the next sub list of the\n * team applications\n */\n\n/**\n * Error returned by linked_apps/list_members_linked_apps\n * @typedef {Object} TeamListMembersAppsError\n * @property {('reset'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * Information returned by linked_apps/list_members_linked_apps.\n * @typedef {Object} TeamListMembersAppsResult\n * @property {Array.<TeamMemberLinkedApps>} apps - The linked applications of\n * each member of the team\n * @property {boolean} has_more - If true, then there are more apps available.\n * Pass the cursor to linked_apps/list_members_linked_apps to retrieve the rest.\n * @property {string} [cursor] - Pass the cursor into\n * linked_apps/list_members_linked_apps to receive the next sub list of team's\n * applications.\n */\n\n/**\n * @typedef {Object} TeamListMembersDevicesArg\n * @property {string} [cursor] - At the first call to the\n * devices/list_members_devices the cursor shouldn't be passed. Then, if the\n * result of the call includes a cursor, the following requests should include\n * the received cursors in order to receive the next sub list of team devices\n * @property {boolean} include_web_sessions - Whether to list web sessions of\n * the team members\n * @property {boolean} include_desktop_clients - Whether to list desktop clients\n * of the team members\n * @property {boolean} include_mobile_clients - Whether to list mobile clients\n * of the team members\n */\n\n/**\n * @typedef {Object} TeamListMembersDevicesError\n * @property {('reset'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} TeamListMembersDevicesResult\n * @property {Array.<TeamMemberDevices>} devices - The devices of each member of\n * the team\n * @property {boolean} has_more - If true, then there are more devices\n * available. Pass the cursor to devices/list_members_devices to retrieve the\n * rest.\n * @property {string} [cursor] - Pass the cursor into\n * devices/list_members_devices to receive the next sub list of team's devices.\n */\n\n/**\n * Arguments for linked_apps/list_team_linked_apps.\n * @typedef {Object} TeamListTeamAppsArg\n * @property {string} [cursor] - At the first call to the\n * linked_apps/list_team_linked_apps the cursor shouldn't be passed. Then, if\n * the result of the call includes a cursor, the following requests should\n * include the received cursors in order to receive the next sub list of the\n * team applications\n */\n\n/**\n * Error returned by linked_apps/list_team_linked_apps\n * @typedef {Object} TeamListTeamAppsError\n * @property {('reset'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * Information returned by linked_apps/list_team_linked_apps.\n * @typedef {Object} TeamListTeamAppsResult\n * @property {Array.<TeamMemberLinkedApps>} apps - The linked applications of\n * each member of the team\n * @property {boolean} has_more - If true, then there are more apps available.\n * Pass the cursor to linked_apps/list_team_linked_apps to retrieve the rest.\n * @property {string} [cursor] - Pass the cursor into\n * linked_apps/list_team_linked_apps to receive the next sub list of team's\n * applications.\n */\n\n/**\n * @typedef {Object} TeamListTeamDevicesArg\n * @property {string} [cursor] - At the first call to the\n * devices/list_team_devices the cursor shouldn't be passed. Then, if the result\n * of the call includes a cursor, the following requests should include the\n * received cursors in order to receive the next sub list of team devices\n * @property {boolean} include_web_sessions - Whether to list web sessions of\n * the team members\n * @property {boolean} include_desktop_clients - Whether to list desktop clients\n * of the team members\n * @property {boolean} include_mobile_clients - Whether to list mobile clients\n * of the team members\n */\n\n/**\n * @typedef {Object} TeamListTeamDevicesError\n * @property {('reset'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} TeamListTeamDevicesResult\n * @property {Array.<TeamMemberDevices>} devices - The devices of each member of\n * the team\n * @property {boolean} has_more - If true, then there are more devices\n * available. Pass the cursor to devices/list_team_devices to retrieve the rest.\n * @property {string} [cursor] - Pass the cursor into devices/list_team_devices\n * to receive the next sub list of team's devices.\n */\n\n/**\n * Specify access type a member should have when joined to a group.\n * @typedef {Object} TeamMemberAccess\n * @property {TeamUserSelectorArg} user - Identity of a user.\n * @property {TeamGroupAccessType} access_type - Access type.\n */\n\n/**\n * @typedef {Object} TeamMemberAddArg\n * @property {string} member_email\n * @property {string} member_given_name - Member's first name.\n * @property {string} member_surname - Member's last name.\n * @property {string} [member_external_id] - External ID for member.\n * @property {string} [member_persistent_id] - Persistent ID for member. This\n * field is only available to teams using persistent ID SAML configuration.\n * @property {boolean} send_welcome_email - Whether to send a welcome email to\n * the member. If send_welcome_email is false, no email invitation will be sent\n * to the user. This may be useful for apps using single sign-on (SSO) flows for\n * onboarding that want to handle announcements themselves.\n * @property {TeamAdminTier} role\n */\n\n/**\n * Describes the result of attempting to add a single user to the team.\n * 'success' is the only value indicating that a user was indeed added to the\n * team - the other values explain the type of failure that occurred, and\n * include the email of the user for which the operation has failed.\n * @typedef {Object} TeamMemberAddResult\n * @property {TeamTeamMemberInfo} [success] - Available if .tag is success.\n * Describes a user that was successfully added to the team.\n * @property {string} [team_license_limit] - Available if .tag is\n * team_license_limit. Team is already full. The organization has no available\n * licenses.\n * @property {string} [free_team_member_limit_reached] - Available if .tag is\n * free_team_member_limit_reached. Team is already full. The free team member\n * limit has been reached.\n * @property {string} [user_already_on_team] - Available if .tag is\n * user_already_on_team. User is already on this team. The provided email\n * address is associated with a user who is already a member of (including in\n * recoverable state) or invited to the team.\n * @property {string} [user_on_another_team] - Available if .tag is\n * user_on_another_team. User is already on another team. The provided email\n * address is associated with a user that is already a member or invited to\n * another team.\n * @property {string} [user_already_paired] - Available if .tag is\n * user_already_paired. User is already paired.\n * @property {string} [user_migration_failed] - Available if .tag is\n * user_migration_failed. User migration has failed.\n * @property {string} [duplicate_external_member_id] - Available if .tag is\n * duplicate_external_member_id. A user with the given external member ID\n * already exists on the team (including in recoverable state).\n * @property {string} [duplicate_member_persistent_id] - Available if .tag is\n * duplicate_member_persistent_id. A user with the given persistent ID already\n * exists on the team (including in recoverable state).\n * @property {string} [persistent_id_disabled] - Available if .tag is\n * persistent_id_disabled. Persistent ID is only available to teams with\n * persistent ID SAML configuration. Please contact Dropbox for more\n * information.\n * @property {string} [user_creation_failed] - Available if .tag is\n * user_creation_failed. User creation has failed.\n * @property {('success'|'team_license_limit'|'free_team_member_limit_reached'|'user_already_on_team'|'user_on_another_team'|'user_already_paired'|'user_migration_failed'|'duplicate_external_member_id'|'duplicate_member_persistent_id'|'persistent_id_disabled'|'user_creation_failed')} .tag - Tag identifying the union variant.\n */\n\n/**\n * Information on devices of a team's member.\n * @typedef {Object} TeamMemberDevices\n * @property {string} team_member_id - The member unique Id\n * @property {Array.<TeamActiveWebSession>} [web_sessions] - List of web\n * sessions made by this team member\n * @property {Array.<TeamDesktopClientSession>} [desktop_clients] - List of\n * desktop clients by this team member\n * @property {Array.<TeamMobileClientSession>} [mobile_clients] - List of mobile\n * clients by this team member\n */\n\n/**\n * Information on linked applications of a team member.\n * @typedef {Object} TeamMemberLinkedApps\n * @property {string} team_member_id - The member unique Id\n * @property {Array.<TeamApiApp>} linked_api_apps - List of third party\n * applications linked by this team member\n */\n\n/**\n * Basic member profile.\n * @typedef {Object} TeamMemberProfile\n * @property {string} team_member_id - ID of user as a member of a team.\n * @property {string} email - Email address of user.\n * @property {boolean} email_verified - Is true if the user's email is verified\n * to be owned by the user.\n * @property {TeamTeamMemberStatus} status - The user's status as a member of a\n * specific team.\n * @property {UsersName} name - Representations for a person's name.\n * @property {TeamTeamMembershipType} membership_type - The user's membership\n * type: full (normal team member) vs limited (does not use a license; no access\n * to the team's shared quota).\n * @property {string} [external_id] - External ID that a team can attach to the\n * user. An application using the API may find it easier to use their own IDs\n * instead of Dropbox IDs like account_id or team_member_id.\n * @property {string} [account_id] - A user's account identifier.\n * @property {Timestamp} [joined_on] - The date and time the user joined as a\n * member of a specific team.\n * @property {string} [persistent_id] - Persistent ID that a team can attach to\n * the user. The persistent ID is unique ID to be used for SAML authentication.\n */\n\n/**\n * @typedef {Object} TeamMemberSelectorError\n * @property {('user_not_found'|'user_not_in_team')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} TeamMembersAddArg\n * @property {Array.<TeamMemberAddArg>} new_members - Details of new members to\n * be added to the team.\n * @property {boolean} force_async - Whether to force the add to happen\n * asynchronously.\n */\n\n/**\n * @typedef {Object} TeamMembersAddJobStatus\n * @property {Array.<TeamMemberAddResult>} [complete] - Available if .tag is\n * complete. The asynchronous job has finished. For each member that was\n * specified in the parameter :type:`MembersAddArg` that was provided to\n * :route:`members/add`, a corresponding item is returned in this list.\n * @property {string} [failed] - Available if .tag is failed. The asynchronous\n * job returned an error. The string contains an error message.\n * @property {('in_progress'|'complete'|'failed')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} TeamMembersAddLaunch\n * @property {string} [async_job_id] - Available if .tag is async_job_id. This\n * response indicates that the processing is asynchronous. The string is an id\n * that can be used to obtain the status of the asynchronous job.\n * @property {Array.<TeamMemberAddResult>} [complete] - Available if .tag is\n * complete.\n * @property {('async_job_id'|'complete')} .tag - Tag identifying the union variant.\n */\n\n/**\n * Exactly one of team_member_id, email, or external_id must be provided to\n * identify the user account.\n * @typedef {Object} TeamMembersDeactivateArg\n * @property {TeamUserSelectorArg} user - Identity of user to remove/suspend.\n * @property {boolean} wipe_data - If provided, controls if the user's data will\n * be deleted on their linked devices.\n */\n\n/**\n * @typedef {Object} TeamMembersDeactivateError\n * @property {('user_not_found'|'user_not_in_team'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} TeamMembersGetInfoArgs\n * @property {Array.<TeamUserSelectorArg>} members - List of team members.\n */\n\n/**\n * @typedef {Object} TeamMembersGetInfoError\n * @property {'other'} .tag - Tag identifying the union variant.\n */\n\n/**\n * Describes a result obtained for a single user whose id was specified in the\n * parameter of members/get_info.\n * @typedef {Object} TeamMembersGetInfoItem\n * @property {string} [id_not_found] - Available if .tag is id_not_found. An ID\n * that was provided as a parameter to :route:`members/get_info`, and did not\n * match a corresponding user. This might be a team_member_id, an email, or an\n * external ID, depending on how the method was called.\n * @property {TeamTeamMemberInfo} [member_info] - Available if .tag is\n * member_info. Info about a team member.\n * @property {('id_not_found'|'member_info')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} TeamMembersListArg\n * @property {number} limit - Number of results to return per call.\n * @property {boolean} include_removed - Whether to return removed members.\n */\n\n/**\n * @typedef {Object} TeamMembersListContinueArg\n * @property {string} cursor - Indicates from what point to get the next set of\n * members.\n */\n\n/**\n * @typedef {Object} TeamMembersListContinueError\n * @property {('invalid_cursor'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} TeamMembersListError\n * @property {'other'} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} TeamMembersListResult\n * @property {Array.<TeamTeamMemberInfo>} members - List of team members.\n * @property {string} cursor - Pass the cursor into members/list/continue to\n * obtain the additional members.\n * @property {boolean} has_more - Is true if there are additional team members\n * that have not been returned yet. An additional call to members/list/continue\n * can retrieve them.\n */\n\n/**\n * Exactly one of team_member_id, email, or external_id must be provided to\n * identify the user account.\n * @typedef {Object} TeamMembersRecoverArg\n * @property {TeamUserSelectorArg} user - Identity of user to recover.\n */\n\n/**\n * @typedef {Object} TeamMembersRecoverError\n * @property {('user_not_found'|'user_unrecoverable'|'user_not_in_team'|'team_license_limit'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} TeamMembersRemoveArg\n * @property {TeamUserSelectorArg} user - Identity of user to remove/suspend.\n * @property {boolean} wipe_data - If provided, controls if the user's data will\n * be deleted on their linked devices.\n * @property {TeamUserSelectorArg} [transfer_dest_id] - If provided, files from\n * the deleted member account will be transferred to this user.\n * @property {TeamUserSelectorArg} [transfer_admin_id] - If provided, errors\n * during the transfer process will be sent via email to this user. If the\n * transfer_dest_id argument was provided, then this argument must be provided\n * as well.\n * @property {boolean} keep_account - Downgrade the member to a Basic account.\n * The user will retain the email address associated with their Dropbox  account\n * and data in their account that is not restricted to team members. In order to\n * keep the account the argument wipe_data should be set to False.\n */\n\n/**\n * @typedef {Object} TeamMembersRemoveError\n * @property {('user_not_found'|'user_not_in_team'|'other'|'remove_last_admin'|'removed_and_transfer_dest_should_differ'|'removed_and_transfer_admin_should_differ'|'transfer_dest_user_not_found'|'transfer_dest_user_not_in_team'|'transfer_admin_user_not_found'|'transfer_admin_user_not_in_team'|'unspecified_transfer_admin_id'|'transfer_admin_is_not_admin'|'cannot_keep_account_and_transfer'|'cannot_keep_account_and_delete_data'|'email_address_too_long_to_be_disabled')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} TeamMembersSendWelcomeError\n * @property {('user_not_found'|'user_not_in_team'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * Exactly one of team_member_id, email, or external_id must be provided to\n * identify the user account.\n * @typedef {Object} TeamMembersSetPermissionsArg\n * @property {TeamUserSelectorArg} user - Identity of user whose role will be\n * set.\n * @property {TeamAdminTier} new_role - The new role of the member.\n */\n\n/**\n * @typedef {Object} TeamMembersSetPermissionsError\n * @property {('user_not_found'|'last_admin'|'user_not_in_team'|'cannot_set_permissions'|'team_license_limit'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} TeamMembersSetPermissionsResult\n * @property {string} team_member_id - The member ID of the user to which the\n * change was applied.\n * @property {TeamAdminTier} role - The role after the change.\n */\n\n/**\n * Exactly one of team_member_id, email, or external_id must be provided to\n * identify the user account. At least one of new_email, new_external_id,\n * new_given_name, and/or new_surname must be provided.\n * @typedef {Object} TeamMembersSetProfileArg\n * @property {TeamUserSelectorArg} user - Identity of user whose profile will be\n * set.\n * @property {string} [new_email] - New email for member.\n * @property {string} [new_external_id] - New external ID for member.\n * @property {string} [new_given_name] - New given name for member.\n * @property {string} [new_surname] - New surname for member.\n * @property {string} [new_persistent_id] - New persistent ID. This field only\n * available to teams using persistent ID SAML configuration.\n */\n\n/**\n * @typedef {Object} TeamMembersSetProfileError\n * @property {('user_not_found'|'user_not_in_team'|'external_id_and_new_external_id_unsafe'|'no_new_data_specified'|'email_reserved_for_other_user'|'external_id_used_by_other_user'|'set_profile_disallowed'|'param_cannot_be_empty'|'persistent_id_disabled'|'persistent_id_used_by_other_user'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} TeamMembersSuspendError\n * @property {('user_not_found'|'user_not_in_team'|'other'|'suspend_inactive_user'|'suspend_last_admin'|'team_license_limit')} .tag - Tag identifying the union variant.\n */\n\n/**\n * Exactly one of team_member_id, email, or external_id must be provided to\n * identify the user account.\n * @typedef {Object} TeamMembersUnsuspendArg\n * @property {TeamUserSelectorArg} user - Identity of user to unsuspend.\n */\n\n/**\n * @typedef {Object} TeamMembersUnsuspendError\n * @property {('user_not_found'|'user_not_in_team'|'other'|'unsuspend_non_suspended_member'|'team_license_limit')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} TeamMobileClientPlatform\n * @property {('iphone'|'ipad'|'android'|'windows_phone'|'blackberry'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * Information about linked Dropbox mobile client sessions\n * @typedef {Object} TeamMobileClientSession\n * @property {string} session_id - The session id\n * @property {string} device_name - The device name\n * @property {TeamMobileClientPlatform} client_type - The mobile application\n * type\n * @property {string} [ip_address] - The IP address of the last activity from\n * this session\n * @property {string} [country] - The country from which the last activity from\n * this session was made\n * @property {Timestamp} [created] - The time this session was created\n * @property {Timestamp} [updated] - The time of the last activity from this\n * session\n * @property {string} [client_version] - The dropbox client version\n * @property {string} [os_version] - The hosting OS version\n * @property {string} [last_carrier] - last carrier used by the device\n */\n\n/**\n * @typedef {Object} TeamRemovedStatus\n * @property {boolean} is_recoverable - True if the removed team member is\n * recoverable\n */\n\n/**\n * @typedef {Object} TeamRevokeDesktopClientArg\n * @property {string} session_id - The session id\n * @property {string} team_member_id - The unique id of the member owning the\n * device\n * @property {boolean} delete_on_unlink - Whether to delete all files of the\n * account (this is possible only if supported by the desktop client and  will\n * be made the next time the client access the account)\n */\n\n/**\n * @typedef {Object} TeamRevokeDeviceSessionArg\n * @property {TeamDeviceSessionArg} [web_session] - Available if .tag is\n * web_session. End an active session\n * @property {TeamRevokeDesktopClientArg} [desktop_client] - Available if .tag\n * is desktop_client. Unlink a linked desktop device\n * @property {TeamDeviceSessionArg} [mobile_client] - Available if .tag is\n * mobile_client. Unlink a linked mobile device\n * @property {('web_session'|'desktop_client'|'mobile_client')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} TeamRevokeDeviceSessionBatchArg\n * @property {Array.<TeamRevokeDeviceSessionArg>} revoke_devices\n */\n\n/**\n * @typedef {Object} TeamRevokeDeviceSessionBatchError\n * @property {'other'} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} TeamRevokeDeviceSessionBatchResult\n * @property {Array.<TeamRevokeDeviceSessionStatus>} revoke_devices_status\n */\n\n/**\n * @typedef {Object} TeamRevokeDeviceSessionError\n * @property {('device_session_not_found'|'member_not_found'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} TeamRevokeDeviceSessionStatus\n * @property {boolean} success - Result of the revoking request\n * @property {TeamRevokeDeviceSessionError} [error_type] - The error cause in\n * case of a failure\n */\n\n/**\n * @typedef {Object} TeamRevokeLinkedApiAppArg\n * @property {string} app_id - The application's unique id\n * @property {string} team_member_id - The unique id of the member owning the\n * device\n * @property {boolean} keep_app_folder - Whether to keep the application\n * dedicated folder (in case the application uses  one)\n */\n\n/**\n * @typedef {Object} TeamRevokeLinkedApiAppBatchArg\n * @property {Array.<TeamRevokeLinkedApiAppArg>} revoke_linked_app\n */\n\n/**\n * Error returned by linked_apps/revoke_linked_app_batch.\n * @typedef {Object} TeamRevokeLinkedAppBatchError\n * @property {'other'} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} TeamRevokeLinkedAppBatchResult\n * @property {Array.<TeamRevokeLinkedAppStatus>} revoke_linked_app_status\n */\n\n/**\n * Error returned by linked_apps/revoke_linked_app.\n * @typedef {Object} TeamRevokeLinkedAppError\n * @property {('app_not_found'|'member_not_found'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} TeamRevokeLinkedAppStatus\n * @property {boolean} success - Result of the revoking request\n * @property {TeamRevokeLinkedAppError} [error_type] - The error cause in case\n * of a failure\n */\n\n/**\n * Describes the number of users in a specific storage bucket.\n * @typedef {Object} TeamStorageBucket\n * @property {string} bucket - The name of the storage bucket. For example, '1G'\n * is a bucket of users with storage size up to 1 Giga.\n * @property {number} users - The number of people whose storage is in the range\n * of this storage bucket.\n */\n\n/**\n * @typedef {Object} TeamTeamFolderAccessError\n * @property {('invalid_team_folder_id'|'no_access'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} TeamTeamFolderActivateError\n * @property {TeamTeamFolderAccessError} [access_error] - Available if .tag is\n * access_error.\n * @property {TeamTeamFolderInvalidStatusError} [status_error] - Available if\n * .tag is status_error.\n * @property {('access_error'|'status_error'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} TeamTeamFolderArchiveArg\n * @property {string} team_folder_id - The ID of the team folder.\n * @property {boolean} force_async_off - Whether to force the archive to happen\n * synchronously.\n */\n\n/**\n * @typedef {Object} TeamTeamFolderArchiveError\n * @property {TeamTeamFolderAccessError} [access_error] - Available if .tag is\n * access_error.\n * @property {TeamTeamFolderInvalidStatusError} [status_error] - Available if\n * .tag is status_error.\n * @property {('access_error'|'status_error'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} TeamTeamFolderArchiveJobStatus\n * @property {TeamTeamFolderMetadata} [complete] - Available if .tag is\n * complete. The archive job has finished. The value is the metadata for the\n * resulting team folder.\n * @property {TeamTeamFolderArchiveError} [failed] - Available if .tag is\n * failed. Error occurred while performing an asynchronous job from\n * :route:`team_folder/archive`.\n * @property {('in_progress'|'complete'|'failed')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} TeamTeamFolderArchiveLaunch\n * @property {string} [async_job_id] - Available if .tag is async_job_id. This\n * response indicates that the processing is asynchronous. The string is an id\n * that can be used to obtain the status of the asynchronous job.\n * @property {TeamTeamFolderMetadata} [complete] - Available if .tag is\n * complete.\n * @property {('async_job_id'|'complete')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} TeamTeamFolderCreateArg\n * @property {string} name - Name for the new team folder.\n */\n\n/**\n * @typedef {Object} TeamTeamFolderCreateError\n * @property {('invalid_folder_name'|'folder_name_already_used'|'folder_name_reserved'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} TeamTeamFolderGetInfoItem\n * @property {string} [id_not_found] - Available if .tag is id_not_found. An ID\n * that was provided as a parameter to :route:`team_folder/get_info` did not\n * match any of the team's team folders.\n * @property {TeamTeamFolderMetadata} [team_folder_metadata] - Available if .tag\n * is team_folder_metadata. Properties of a team folder.\n * @property {('id_not_found'|'team_folder_metadata')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} TeamTeamFolderIdArg\n * @property {string} team_folder_id - The ID of the team folder.\n */\n\n/**\n * @typedef {Object} TeamTeamFolderIdListArg\n * @property {Array.<Object>} team_folder_ids - The list of team folder IDs.\n */\n\n/**\n * @typedef {Object} TeamTeamFolderInvalidStatusError\n * @property {('active'|'archived'|'archive_in_progress'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} TeamTeamFolderListArg\n * @property {number} limit - The maximum number of results to return per\n * request.\n */\n\n/**\n * @typedef {Object} TeamTeamFolderListError\n * @property {TeamTeamFolderAccessError} access_error\n */\n\n/**\n * Result for team_folder/list.\n * @typedef {Object} TeamTeamFolderListResult\n * @property {Array.<TeamTeamFolderMetadata>} team_folders - List of all team\n * folders in the authenticated team.\n */\n\n/**\n * Properties of a team folder.\n * @typedef {Object} TeamTeamFolderMetadata\n * @property {string} team_folder_id - The ID of the team folder.\n * @property {string} name - The name of the team folder.\n * @property {TeamTeamFolderStatus} status - The status of the team folder.\n */\n\n/**\n * @typedef {Object} TeamTeamFolderPermanentlyDeleteError\n * @property {TeamTeamFolderAccessError} [access_error] - Available if .tag is\n * access_error.\n * @property {TeamTeamFolderInvalidStatusError} [status_error] - Available if\n * .tag is status_error.\n * @property {('access_error'|'status_error'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} TeamTeamFolderRenameArg\n * @property {string} team_folder_id - The ID of the team folder.\n * @property {string} name - New team folder name.\n */\n\n/**\n * @typedef {Object} TeamTeamFolderRenameError\n * @property {TeamTeamFolderAccessError} [access_error] - Available if .tag is\n * access_error.\n * @property {TeamTeamFolderInvalidStatusError} [status_error] - Available if\n * .tag is status_error.\n * @property {('access_error'|'status_error'|'other'|'invalid_folder_name'|'folder_name_already_used'|'folder_name_reserved')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} TeamTeamFolderStatus\n * @property {('active'|'archived'|'archive_in_progress'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} TeamTeamGetInfoResult\n * @property {string} name - The name of the team.\n * @property {string} team_id - The ID of the team.\n * @property {number} num_licensed_users - The number of licenses available to\n * the team.\n * @property {number} num_provisioned_users - The number of accounts that have\n * been invited or are already active members of the team.\n * @property {TeamPoliciesTeamMemberPolicies} policies\n */\n\n/**\n * Information about a team member.\n * @typedef {Object} TeamTeamMemberInfo\n * @property {TeamTeamMemberProfile} profile - Profile of a user as a member of\n * a team.\n * @property {TeamAdminTier} role - The user's role in the team.\n */\n\n/**\n * Profile of a user as a member of a team.\n * @typedef {Object} TeamTeamMemberProfile\n * @property {string} team_member_id - ID of user as a member of a team.\n * @property {string} email - Email address of user.\n * @property {boolean} email_verified - Is true if the user's email is verified\n * to be owned by the user.\n * @property {TeamTeamMemberStatus} status - The user's status as a member of a\n * specific team.\n * @property {UsersName} name - Representations for a person's name.\n * @property {TeamTeamMembershipType} membership_type - The user's membership\n * type: full (normal team member) vs limited (does not use a license; no access\n * to the team's shared quota).\n * @property {Array.<Object>} groups - List of group IDs of groups that the user\n * belongs to.\n * @property {string} [external_id] - External ID that a team can attach to the\n * user. An application using the API may find it easier to use their own IDs\n * instead of Dropbox IDs like account_id or team_member_id.\n * @property {string} [account_id] - A user's account identifier.\n * @property {Timestamp} [joined_on] - The date and time the user joined as a\n * member of a specific team.\n * @property {string} [persistent_id] - Persistent ID that a team can attach to\n * the user. The persistent ID is unique ID to be used for SAML authentication.\n */\n\n/**\n * The user's status as a member of a specific team.\n * @typedef {Object} TeamTeamMemberStatus\n * @property {TeamRemovedStatus} [removed] - Available if .tag is removed. User\n * is no longer a member of the team. Removed users are only listed when\n * include_removed is true in members/list.\n * @property {('active'|'invited'|'suspended'|'removed')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} TeamTeamMembershipType\n * @property {('full'|'limited')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} TeamUpdatePropertyTemplateArg\n * @property {string} template_id - An identifier for property template added by\n * properties/template/add.\n * @property {string} [name] - A display name for the property template.\n * Property template names can be up to 256 bytes.\n * @property {string} [description] - Description for new property template.\n * Property template descriptions can be up to 1024 bytes.\n * @property {Array.<PropertiesPropertyFieldTemplate>} [add_fields] - This is a\n * list of custom properties to add to the property template. There can be up to\n * 64 properties in a single property template.\n */\n\n/**\n * @typedef {Object} TeamUpdatePropertyTemplateResult\n * @property {string} template_id - An identifier for property template added by\n * properties/template/add.\n */\n\n/**\n * Argument for selecting a single user, either by team_member_id, external_id\n * or email.\n * @typedef {Object} TeamUserSelectorArg\n * @property {string} [team_member_id] - Available if .tag is team_member_id.\n * @property {string} [external_id] - Available if .tag is external_id.\n * @property {string} [email] - Available if .tag is email.\n * @property {('team_member_id'|'external_id'|'email')} .tag - Tag identifying the union variant.\n */\n\n/**\n * Error that can be returned whenever a struct derived from UserSelectorArg is\n * used.\n * @typedef {Object} TeamUserSelectorError\n * @property {'user_not_found'} .tag - Tag identifying the union variant.\n */\n\n/**\n * Argument for selecting a list of users, either by team_member_ids,\n * external_ids or emails.\n * @typedef {Object} TeamUsersSelectorArg\n * @property {Array.<Object>} [team_member_ids] - Available if .tag is\n * team_member_ids. List of member IDs.\n * @property {Array.<Object>} [external_ids] - Available if .tag is\n * external_ids. List of external user IDs.\n * @property {Array.<Object>} [emails] - Available if .tag is emails. List of\n * email addresses.\n * @property {('team_member_ids'|'external_ids'|'emails')} .tag - Tag identifying the union variant.\n */\n\n/**\n * The group type determines how a group is managed.\n * @typedef {Object} TeamCommonGroupManagementType\n * @property {('user_managed'|'company_managed'|'system_managed'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * Information about a group.\n * @typedef {Object} TeamCommonGroupSummary\n * @property {string} group_name\n * @property {string} group_id\n * @property {TeamCommonGroupManagementType} group_management_type - Who is\n * allowed to manage the group.\n * @property {string} [group_external_id] - External ID of group. This is an\n * arbitrary ID that an admin can attach to a group.\n * @property {number} [member_count] - The number of members in the group.\n */\n\n/**\n * The group type determines how a group is created and managed.\n * @typedef {Object} TeamCommonGroupType\n * @property {('team'|'user_managed'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * Time range.\n * @typedef {Object} TeamCommonTimeRange\n * @property {Timestamp} [start_time] - Optional starting time (inclusive).\n * @property {Timestamp} [end_time] - Optional ending time (exclusive).\n */\n\n/**\n * @typedef {Object} TeamPoliciesEmmState\n * @property {('disabled'|'optional'|'required'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * Policy governing which shared folders a team member can join.\n * @typedef {Object} TeamPoliciesSharedFolderJoinPolicy\n * @property {('from_team_only'|'from_anyone'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * Policy governing who can be a member of a folder shared by a team member.\n * @typedef {Object} TeamPoliciesSharedFolderMemberPolicy\n * @property {('team'|'anyone'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * Policy governing the visibility of shared links. This policy can apply to\n * newly created shared links, or all shared links.\n * @typedef {Object} TeamPoliciesSharedLinkCreatePolicy\n * @property {('default_public'|'default_team_only'|'team_only'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * Policies governing team members.\n * @typedef {Object} TeamPoliciesTeamMemberPolicies\n * @property {TeamPoliciesTeamSharingPolicies} sharing - Policies governing\n * sharing.\n * @property {TeamPoliciesEmmState} emm_state - This describes the Enterprise\n * Mobility Management (EMM) state for this team. This information can be used\n * to understand if an organization is integrating with a third-party EMM vendor\n * to further manage and apply restrictions upon the team's Dropbox usage on\n * mobile devices. This is a new feature and in the future we'll be adding more\n * new fields and additional documentation.\n */\n\n/**\n * Policies governing sharing within and outside of the team.\n * @typedef {Object} TeamPoliciesTeamSharingPolicies\n * @property {TeamPoliciesSharedFolderMemberPolicy} shared_folder_member_policy\n * - Who can join folders shared by team members.\n * @property {TeamPoliciesSharedFolderJoinPolicy} shared_folder_join_policy -\n * Which shared folders team members can join.\n * @property {TeamPoliciesSharedLinkCreatePolicy} shared_link_create_policy -\n * Who can view shared links owned by team members.\n */\n\n/**\n * The amount of detail revealed about an account depends on the user being\n * queried and the user making the query.\n * @typedef {Object} UsersAccount\n * @property {string} account_id - The user's unique Dropbox ID.\n * @property {UsersName} name - Details of a user's name.\n * @property {string} email - The user's e-mail address. Do not rely on this\n * without checking the email_verified field. Even then, it's possible that the\n * user has since lost access to their e-mail.\n * @property {boolean} email_verified - Whether the user has verified their\n * e-mail address.\n * @property {boolean} disabled - Whether the user has been disabled.\n * @property {string} [profile_photo_url] - URL for the photo representing the\n * user, if one is set.\n */\n\n/**\n * What type of account this user has.\n * @typedef {Object} UsersAccountType\n * @property {('basic'|'pro'|'business')} .tag - Tag identifying the union variant.\n */\n\n/**\n * Basic information about any account.\n * @typedef {Object} UsersBasicAccount\n * @property {string} account_id - The user's unique Dropbox ID.\n * @property {UsersName} name - Details of a user's name.\n * @property {string} email - The user's e-mail address. Do not rely on this\n * without checking the email_verified field. Even then, it's possible that the\n * user has since lost access to their e-mail.\n * @property {boolean} email_verified - Whether the user has verified their\n * e-mail address.\n * @property {boolean} disabled - Whether the user has been disabled.\n * @property {boolean} is_teammate - Whether this user is a teammate of the\n * current user. If this account is the current user's account, then this will\n * be true.\n * @property {string} [profile_photo_url] - URL for the photo representing the\n * user, if one is set.\n * @property {string} [team_member_id] - The user's unique team member id. This\n * field will only be present if the user is part of a team and is_teammate is\n * true.\n */\n\n/**\n * Detailed information about the current user's account.\n * @typedef {Object} UsersFullAccount\n * @property {string} account_id - The user's unique Dropbox ID.\n * @property {UsersName} name - Details of a user's name.\n * @property {string} email - The user's e-mail address. Do not rely on this\n * without checking the email_verified field. Even then, it's possible that the\n * user has since lost access to their e-mail.\n * @property {boolean} email_verified - Whether the user has verified their\n * e-mail address.\n * @property {boolean} disabled - Whether the user has been disabled.\n * @property {string} locale - The language that the user specified. Locale tags\n * will be IETF language tags http://en.wikipedia.org/wiki/IETF_language_tag.\n * @property {string} referral_link - The user's referral link\n * https://www.dropbox.com/referrals.\n * @property {boolean} is_paired - Whether the user has a personal and work\n * account. If the current account is personal, then team will always be null,\n * but is_paired will indicate if a work account is linked.\n * @property {UsersAccountType} account_type - What type of account this user\n * has.\n * @property {string} [profile_photo_url] - URL for the photo representing the\n * user, if one is set.\n * @property {string} [country] - The user's two-letter country code, if\n * available. Country codes are based on ISO 3166-1\n * http://en.wikipedia.org/wiki/ISO_3166-1.\n * @property {UsersFullTeam} [team] - If this account is a member of a team,\n * information about that team.\n * @property {string} [team_member_id] - This account's unique team member id.\n * This field will only be present if team is present.\n */\n\n/**\n * Detailed information about a team.\n * @typedef {Object} UsersFullTeam\n * @property {string} id - The team's unique ID.\n * @property {string} name - The name of the team.\n * @property {TeamPoliciesTeamSharingPolicies} sharing_policies - Team policies\n * governing sharing.\n */\n\n/**\n * @typedef {Object} UsersGetAccountArg\n * @property {string} account_id - A user's account identifier.\n */\n\n/**\n * @typedef {Object} UsersGetAccountBatchArg\n * @property {Array.<Object>} account_ids - List of user account identifiers.\n * Should not contain any duplicate account IDs.\n */\n\n/**\n * @typedef {Object} UsersGetAccountBatchError\n * @property {string} [no_account] - Available if .tag is no_account. The value\n * is an account ID specified in :field:`GetAccountBatchArg.account_ids` that\n * does not exist.\n * @property {('no_account'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} UsersGetAccountError\n * @property {('no_account'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * @typedef {Object} UsersIndividualSpaceAllocation\n * @property {number} allocated - The total space allocated to the user's\n * account (bytes).\n */\n\n/**\n * Representations for a person's name to assist with internationalization.\n * @typedef {Object} UsersName\n * @property {string} given_name - Also known as a first name.\n * @property {string} surname - Also known as a last name or family name.\n * @property {string} familiar_name - Locale-dependent name. In the US, a\n * person's familiar name is their given_name, but elsewhere, it could be any\n * combination of a person's given_name and surname.\n * @property {string} display_name - A name that can be used directly to\n * represent the name of a user's Dropbox account.\n * @property {string} abbreviated_name - An abbreviated form of the person's\n * name. Their initials in most locales.\n */\n\n/**\n * Space is allocated differently based on the type of account.\n * @typedef {Object} UsersSpaceAllocation\n * @property {UsersIndividualSpaceAllocation} [individual] - Available if .tag\n * is individual. The user's space allocation applies only to their individual\n * account.\n * @property {UsersTeamSpaceAllocation} [team] - Available if .tag is team. The\n * user shares space with other members of their team.\n * @property {('individual'|'team'|'other')} .tag - Tag identifying the union variant.\n */\n\n/**\n * Information about a user's space usage and quota.\n * @typedef {Object} UsersSpaceUsage\n * @property {number} used - The user's total space usage (bytes).\n * @property {UsersSpaceAllocation} allocation - The user's space allocation.\n */\n\n/**\n * Information about a team.\n * @typedef {Object} UsersTeam\n * @property {string} id - The team's unique ID.\n * @property {string} name - The name of the team.\n */\n\n/**\n * @typedef {Object} UsersTeamSpaceAllocation\n * @property {number} used - The total space currently used by the user's team\n * (bytes).\n * @property {number} allocated - The total space allocated to the user's team\n * (bytes).\n */\n","/home/travis/build/npmtest/node-npmtest-dropbox/node_modules/dropbox/src/upload-request.js":"var request = require('superagent');\nvar Promise = require('es6-promise').Promise;\nvar getBaseURL = require('./get-base-url');\nvar httpHeaderSafeJson = require('./http-header-safe-json');\n\n// This doesn't match what was spec'd in paper doc yet\nvar buildCustomError = function (error, response) {\n  return {\n    status: error.status,\n    error: (response ? response.text : null) || error.toString(),\n    response: response\n  };\n};\n\nvar uploadRequest = function (path, args, auth, host, accessToken, selectUser) {\n  if (auth !== 'user') {\n    throw new Error('Unexpected auth type: ' + auth);\n  }\n\n  var promiseFunction = function (resolve, reject) {\n    var apiRequest;\n\n    // Since args.contents is sent as the body of the request and not added to\n    // the url, it needs to be remove it from args.\n    var contents = args.contents;\n    delete args.contents;\n\n    function success(data) {\n      if (resolve) {\n        resolve(data);\n      }\n    }\n\n    function failure(error) {\n      if (reject) {\n        reject(error);\n      }\n    }\n\n    function responseHandler(error, response) {\n      if (error) {\n        failure(buildCustomError(error, response));\n      } else {\n        success(response.body);\n      }\n    }\n\n    apiRequest = request.post(getBaseURL(host) + path)\n      .type('application/octet-stream')\n      .set('Authorization', 'Bearer ' + accessToken)\n      .set('Dropbox-API-Arg', httpHeaderSafeJson(args));\n\n    if (selectUser) {\n      apiRequest = apiRequest.set('Dropbox-API-Select-User', selectUser);\n    }\n\n    apiRequest\n      .send(contents)\n      .end(responseHandler);\n  };\n\n  return new Promise(promiseFunction);\n};\n\nmodule.exports = uploadRequest;\n"}